# Project Structure

```
├── __pycache__
│   ├── actions.cpython-313.pyc
│   ├── background_process.cpython-313.pyc
│   ├── device_state_manager.cpython-313.pyc
│   ├── logical_process.cpython-313.pyc
│   ├── screenrecord_manager.cpython-313.pyc
│   ├── settings.cpython-313.pyc
│   └── suppress_warnings.cpython-313.pyc
├── device_states
│   ├── DEVICE1.json
│   ├── DEVICE10.json
│   ├── DEVICE2.json
│   ├── DEVICE3.json
│   ├── DEVICE4.json
│   ├── DEVICE5.json
│   ├── DEVICE6.json
│   ├── DEVICE7.json
│   ├── DEVICE8.json
│   └── DEVICE9.json
├── tasks
│   ├── __pycache__
│   │   ├── __init__.cpython-313.pyc
│   │   ├── detect_chapter_end.cpython-313.pyc
│   │   ├── guild_tasks.cpython-313.pyc
│   │   ├── hard_story.cpython-313.pyc
│   │   ├── main_tasks.cpython-313.pyc
│   │   ├── restarting_tasks.cpython-313.pyc
│   │   ├── sell_characters_tasks.cpython-313.pyc
│   │   ├── shared_tasks.cpython-313.pyc
│   │   ├── side_story.cpython-313.pyc
│   │   ├── sub_stories_check.cpython-313.pyc
│   │   ├── sub_stories.cpython-313.pyc
│   │   └── switcher_tasks.cpython-313.pyc
│   ├── __init__.py
│   ├── detect_chapter_end.py
│   ├── guild_tasks.py
│   ├── hard_story.py
│   ├── main_tasks.py
│   ├── restarting_tasks.py
│   ├── sell_characters_tasks.py
│   ├── shared_tasks.py
│   ├── side_story.py
│   ├── sub_stories_check.py
│   ├── sub_stories.py
│   └── switcher_tasks.py
├── templates
│   ├── Easy-Hard
│   │   ├── Part1-Chapter29_Hard.png
│   │   ├── Part1-Chapter29.png
│   │   ├── Part10-Chapter299.png
│   │   ├── Part11-Chapter320.png
│   │   ├── Part12-Chapter352.png
│   │   ├── Part13-Chapter387.png
│   │   ├── Part14-Chapter398.png
│   │   ├── Part15-Chapter410.png
│   │   ├── Part16-Chapter421.png
│   │   ├── Part17-Chapter436.png
│   │   ├── Part18-Chapter449.png
│   │   ├── Part19-Chapter464.png
│   │   ├── Part2-Chapter66.png
│   │   ├── Part20-Chapter483.png
│   │   ├── Part21_Finished_Hard.png
│   │   ├── Part21-Chapter502.png
│   │   ├── Part3-Chapter110.png
│   │   ├── Part4-Chapter154.png
│   │   ├── Part5-Chapter180.png
│   │   ├── Part6-Chapter204.png
│   │   ├── Part7-Chapter229.png
│   │   ├── Part8-Chapter247.png
│   │   ├── Part9-Chapter273_Hard.png
│   │   └── Part9-Chapter273.png
│   ├── Guild
│   │   ├── GuildIcon.png
│   │   ├── GuildTOP.png
│   │   ├── Join.png
│   │   └── OKGUILD.png
│   ├── Purchase_Tickets
│   │   ├── 25Tickets.png
│   │   ├── Purchase.png
│   │   └── PurchaseTickets.png
│   ├── Restarting
│   │   ├── Exit.png
│   │   ├── OK.png
│   │   └── Solo.png
│   ├── Sell_Characters
│   │   ├── 3StarsSell.png
│   │   ├── ALL.png
│   │   ├── CharacterList.png
│   │   ├── CharacterList2.png
│   │   └── Close.png
│   ├── Shared
│   │   ├── Close.png
│   │   ├── Resume.png
│   │   ├── Retry_Connection_Blue.png
│   │   ├── Retry_Connection_Red.png
│   │   └── Skip.png
│   ├── Side-Story
│   │   ├── S_Part1-Chapter40_Easy.png
│   │   ├── S_Part10-Chapter33_Easy.png
│   │   ├── S_Part11-Chapter36_Easy.png
│   │   ├── S_Part12-Chapter15_Easy.png
│   │   ├── S_Part13-Chapter35_Easy.png
│   │   ├── S_Part14-Chapter65_Easy.png
│   │   ├── S_Part15-Chapter95_Easy.png
│   │   ├── S_Part16-Chapter133_Easy.png
│   │   ├── S_Part17-Chapter166_Easy.png
│   │   ├── S_Part17-Chapter166_Hard.png
│   │   ├── S_Part18-Chapter192_Easy.png
│   │   ├── S_Part19-Chapter226_Easy.png
│   │   ├── S_Part2-Chapter77_Easy.png
│   │   ├── S_Part20-Chapter29_Easy.png
│   │   ├── S_Part21-Chapter58_Easy.png
│   │   ├── S_Part22-Chapter87_Easy.png
│   │   ├── S_Part23-Chapter117_Easy.png
│   │   ├── S_Part24-Chapter153_Easy.png
│   │   ├── S_Part3-Chapter114_Easy.png
│   │   ├── S_Part4-Chapter39_Easy.png
│   │   ├── S_Part5-Chapter74_Easy.png
│   │   ├── S_Part6-Chapter36_Easy.png
│   │   ├── S_Part7-Chapter71_Easy.png
│   │   ├── S_Part8-Chapter33_Easy.png
│   │   └── S_Part9-Chapter33_Easy.png
│   ├── Story_Mode
│   │   ├── ClearStory.png
│   │   ├── feetMap.png
│   │   ├── MapStep.png
│   │   ├── NextStories.png
│   │   ├── Part21_full.png
│   │   ├── Stars.png
│   │   ├── StoryMAP.png
│   │   ├── UnClearedPart.png
│   │   └── UnClearedPart2.png
│   ├── Story_Mode_Hard
│   │   ├── Part1_hard.png
│   │   └── S_Part1_hard.png
│   ├── Sub-Stories
│   │   ├── Sub-Storie-1-New.png
│   │   ├── Sub-Storie-2-New.png
│   │   ├── Sub-Storie-3-New.png
│   │   ├── Sub-Storie-4-New.png
│   │   ├── Sub-Storie-5-New.png
│   │   └── Sub-Storie-Map-UnClear.png
│   └── Switcher
│       └── ArrowShowedUP.png
├── testing
│   ├── debug_stars.py
│   ├── find_image_pixels.py
│   ├── image_browser.py
│   ├── kill_processes.bat
│   ├── roi_selector.py
│   ├── select_crop.py
│   ├── test_keep_checking.py
│   ├── test_matching_type.py
│   ├── test_matching.py
│   ├── test_ocr.py
│   ├── test_pixel_one_or_more.py
│   ├── test_substories_check_integration.py
│   └── test_template_matching.py
├── actions.py
├── background_process.py
├── code.txt
├── device_state_manager.py
├── logical_process.py
├── main.py
├── requirements.txt
├── screenrecord_manager.py
├── settings.py
├── suppress_warnings.py
└── task_runner.py
```




# Project Structure

```
├── __pycache__
│   ├── actions.cpython-313.pyc
│   ├── background_process.cpython-313.pyc
│   ├── device_state_manager.cpython-313.pyc
│   ├── logical_process.cpython-313.pyc
│   ├── screenrecord_manager.cpython-313.pyc
│   ├── settings.cpython-313.pyc
│   └── suppress_warnings.cpython-313.pyc
├── device_states
│   ├── DEVICE1.json
│   ├── DEVICE10.json
│   ├── DEVICE2.json
│   ├── DEVICE3.json
│   ├── DEVICE4.json
│   ├── DEVICE5.json
│   ├── DEVICE6.json
│   ├── DEVICE7.json
│   ├── DEVICE8.json
│   └── DEVICE9.json
├── tasks
│   ├── __pycache__
│   │   ├── __init__.cpython-313.pyc
│   │   ├── detect_chapter_end.cpython-313.pyc
│   │   ├── guild_tasks.cpython-313.pyc
│   │   ├── hard_story.cpython-313.pyc
│   │   ├── main_tasks.cpython-313.pyc
│   │   ├── restarting_tasks.cpython-313.pyc
│   │   ├── sell_characters_tasks.cpython-313.pyc
│   │   ├── shared_tasks.cpython-313.pyc
│   │   ├── side_story.cpython-313.pyc
│   │   ├── sub_stories_check.cpython-313.pyc
│   │   ├── sub_stories.cpython-313.pyc
│   │   └── switcher_tasks.cpython-313.pyc
│   ├── __init__.py
│   ├── detect_chapter_end.py
│   ├── guild_tasks.py
│   ├── hard_story.py
│   ├── main_tasks.py
│   ├── restarting_tasks.py
│   ├── sell_characters_tasks.py
│   ├── shared_tasks.py
│   ├── side_story.py
│   ├── sub_stories_check.py
│   ├── sub_stories.py
│   └── switcher_tasks.py
├── templates
│   ├── Easy-Hard
│   │   ├── Part1-Chapter29_Hard.png
│   │   ├── Part1-Chapter29.png
│   │   ├── Part10-Chapter299.png
│   │   ├── Part11-Chapter320.png
│   │   ├── Part12-Chapter352.png
│   │   ├── Part13-Chapter387.png
│   │   ├── Part14-Chapter398.png
│   │   ├── Part15-Chapter410.png
│   │   ├── Part16-Chapter421.png
│   │   ├── Part17-Chapter436.png
│   │   ├── Part18-Chapter449.png
│   │   ├── Part19-Chapter464.png
│   │   ├── Part2-Chapter66.png
│   │   ├── Part20-Chapter483.png
│   │   ├── Part21_Finished_Hard.png
│   │   ├── Part21-Chapter502.png
│   │   ├── Part3-Chapter110.png
│   │   ├── Part4-Chapter154.png
│   │   ├── Part5-Chapter180.png
│   │   ├── Part6-Chapter204.png
│   │   ├── Part7-Chapter229.png
│   │   ├── Part8-Chapter247.png
│   │   ├── Part9-Chapter273_Hard.png
│   │   └── Part9-Chapter273.png
│   ├── Guild
│   │   ├── GuildIcon.png
│   │   ├── GuildTOP.png
│   │   ├── Join.png
│   │   └── OKGUILD.png
│   ├── Purchase_Tickets
│   │   ├── 25Tickets.png
│   │   ├── Purchase.png
│   │   └── PurchaseTickets.png
│   ├── Restarting
│   │   ├── Exit.png
│   │   ├── OK.png
│   │   └── Solo.png
│   ├── Sell_Characters
│   │   ├── 3StarsSell.png
│   │   ├── ALL.png
│   │   ├── CharacterList.png
│   │   ├── CharacterList2.png
│   │   └── Close.png
│   ├── Shared
│   │   ├── Close.png
│   │   ├── Resume.png
│   │   ├── Retry_Connection_Blue.png
│   │   ├── Retry_Connection_Red.png
│   │   └── Skip.png
│   ├── Side-Story
│   │   ├── S_Part1-Chapter40_Easy.png
│   │   ├── S_Part10-Chapter33_Easy.png
│   │   ├── S_Part11-Chapter36_Easy.png
│   │   ├── S_Part12-Chapter15_Easy.png
│   │   ├── S_Part13-Chapter35_Easy.png
│   │   ├── S_Part14-Chapter65_Easy.png
│   │   ├── S_Part15-Chapter95_Easy.png
│   │   ├── S_Part16-Chapter133_Easy.png
│   │   ├── S_Part17-Chapter166_Easy.png
│   │   ├── S_Part17-Chapter166_Hard.png
│   │   ├── S_Part18-Chapter192_Easy.png
│   │   ├── S_Part19-Chapter226_Easy.png
│   │   ├── S_Part2-Chapter77_Easy.png
│   │   ├── S_Part20-Chapter29_Easy.png
│   │   ├── S_Part21-Chapter58_Easy.png
│   │   ├── S_Part22-Chapter87_Easy.png
│   │   ├── S_Part23-Chapter117_Easy.png
│   │   ├── S_Part24-Chapter153_Easy.png
│   │   ├── S_Part3-Chapter114_Easy.png
│   │   ├── S_Part4-Chapter39_Easy.png
│   │   ├── S_Part5-Chapter74_Easy.png
│   │   ├── S_Part6-Chapter36_Easy.png
│   │   ├── S_Part7-Chapter71_Easy.png
│   │   ├── S_Part8-Chapter33_Easy.png
│   │   └── S_Part9-Chapter33_Easy.png
│   ├── Story_Mode
│   │   ├── ClearStory.png
│   │   ├── feetMap.png
│   │   ├── MapStep.png
│   │   ├── NextStories.png
│   │   ├── Part21_full.png
│   │   ├── Stars.png
│   │   ├── StoryMAP.png
│   │   ├── UnClearedPart.png
│   │   └── UnClearedPart2.png
│   ├── Story_Mode_Hard
│   │   ├── Part1_hard.png
│   │   └── S_Part1_hard.png
│   ├── Sub-Stories
│   │   ├── Sub-Storie-1-New.png
│   │   ├── Sub-Storie-2-New.png
│   │   ├── Sub-Storie-3-New.png
│   │   ├── Sub-Storie-4-New.png
│   │   ├── Sub-Storie-5-New.png
│   │   └── Sub-Storie-Map-UnClear.png
│   └── Switcher
│       └── ArrowShowedUP.png
├── testing
│   ├── debug_stars.py
│   ├── find_image_pixels.py
│   ├── image_browser.py
│   ├── kill_processes.bat
│   ├── roi_selector.py
│   ├── select_crop.py
│   ├── test_keep_checking.py
│   ├── test_matching_type.py
│   ├── test_matching.py
│   ├── test_ocr.py
│   ├── test_pixel_one_or_more.py
│   ├── test_substories_check_integration.py
│   └── test_template_matching.py
├── actions.py
├── background_process.py
├── code.txt
├── device_state_manager.py
├── logical_process.py
├── main.py
├── requirements.txt
├── screenrecord_manager.py
├── settings.py
├── suppress_warnings.py
└── task_runner.py
```

# File Contents

## tasks/__init__.py

```python
# tasks/__init__.py - Central import for all task modules

from .main_tasks import Main_Tasks
from .restarting_tasks import Restarting_Tasks
from .shared_tasks import Shared_Tasks
from .switcher_tasks import Switcher_Tasks
from .guild_tasks import GUILD_TUTORIAL_TASKS, Guild_Rejoin
from .sell_characters_tasks import Sell_Characters
from .hard_story import HardStory_Tasks
from .side_story import SideStory
from .sub_stories import SubStories
from .sub_stories_check import SubStories_check

__all__ = [
    'Main_Tasks',
    'Restarting_Tasks',
    'Shared_Tasks',
    'Switcher_Tasks',
    'GUILD_TUTORIAL_TASKS',
    'Guild_Rejoin',
    'Sell_Characters',
    'HardStory_Tasks',
    'SideStory',
    'SubStories',
    'SubStories_check'
]
```

## tasks/__pycache__/__init__.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/detect_chapter_end.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/guild_tasks.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/hard_story.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/main_tasks.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/restarting_tasks.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/sell_characters_tasks.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/shared_tasks.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/side_story.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/sub_stories.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/sub_stories_check.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/__pycache__/switcher_tasks.cpython-313.pyc

```pyc
[Binary file content not included]
```

## tasks/detect_chapter_end.py

```python
DETECT_CHAPTER_END = [
    {
        "task_name": "Part 1 Chapter END [29]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part1-Chapter29.png",
        "roi": [765, 346, 114, 62],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
        {
        "task_name": "Part 1 Chapter END [29 HARD]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part1-Chapter29_Hard.png",
        "roi": [765, 346, 114, 62],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 2 Chapter END [66]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part2-Chapter66.png",
        "roi": [768, 345, 115, 86],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 3 Chapter END [110]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part3-Chapter110.png",
        "roi": [777, 350, 99, 66],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 4 Chapter END [154]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part4-Chapter154.png",
        "roi": [799, 348, 98, 60],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 5 Chapter END [180]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part5-Chapter180.png",
        "roi": [756, 282, 92, 52],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 6 Chapter END [204]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part6-Chapter204.png",
        "roi": [793, 282, 92, 55],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 7 Chapter END [229]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part7-Chapter229.png",
        "roi": [771, 345, 109, 64],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 8 Chapter END [247]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part8-Chapter247.png",
        "roi": [772, 346, 108, 63],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 9 Chapter END [273]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part9-Chapter273.png",
        "roi": [749, 281, 114, 59],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
        {
        "task_name": "Part 9 Chapter END [273 HARD]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part9-Chapter273_Hard.png",
        "roi": [749, 281, 114, 59],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 10 Chapter END [299]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part10-Chapter299.png",
        "roi": [769, 347, 115, 54],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 11 Chapter END [320]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part11-Chapter320.png",
        "roi": [748, 284, 111, 61],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 12 Chapter END [352]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part12-Chapter352.png",
        "roi": [784, 349, 88, 72],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 13 Chapter END [387]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part13-Chapter387.png",
        "roi": [762, 283, 85, 56],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 14 Chapter END [398]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part14-Chapter398.png",
        "roi": [418, 348, 126, 79],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 15 Chapter END [410]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part15-Chapter410.png",
        "roi": [644, 278, 120, 75],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 16 Chapter END [421]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part16-Chapter421.png",
        "roi": [425, 347, 122, 75],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
        {
        "task_name": "Part 17 Chapter END [436]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part17-Chapter436.png",
        "roi": [759, 346, 129, 80],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 18 Chapter END [449]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part18-Chapter449.png",
        "roi": [704, 344, 136, 83],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 19 Chapter END [464]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part19-Chapter464.png",
        "roi": [757, 350, 122, 75],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 20 Chapter END [483]",
        "type": "template",
        "template_path": "templates/Easy-Hard/Part20-Chapter483.png",
        "roi": [739, 278, 137, 88],
        "click_location_str": "76,480",
        "use_match_position": False,
"confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Part 21 Chapter END [502] SWITCH TO HARD",
        "type": "pixel",
        "click_location_str": "76,480",
        "search_array": ["227,71","#000000","235,74","#000000","239,88","#060606","234,87","#000000","230,87","#000000","794,342","#0199ff","528,200","#51b7dd"],
        "priority": 5,
        "HardStory": True,  # Switches to HardStory_tasks
    },
            {
        "task_name": "Part 21 Hard Chapter END [502] SWITCH TO SIDE",
        "type": "pixel",
        "click_location_str": "0,0",
        "search_array": ["227,71","#000000","235,74","#000000","239,88","#060606","234,87","#000000","230,87","#000000","794,342","#0199ff","267,190","#981e3b"],
        "use_match_position": False,
        "priority": 5,
        "SideStory": True,  # Switches to SideStory_tasks
    },



    # Side Story Easy + HARD
        {
        "task_name": "Side-Story Part 1 Chapter END [40]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part1-Chapter40_Easy.png",
        "roi": [779, 280, 117, 68],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 2 Chapter END [77]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part2-Chapter77_Easy.png",
        "roi": [775, 346, 102, 63],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 3 Chapter END [114]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part3-Chapter114_Easy.png",
        "roi": [750, 281, 107, 67],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 4 Chapter END [39]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part4-Chapter39_Easy.png",
        "roi": [770, 327, 120, 88],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 5 Chapter END [74]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part5-Chapter74_Easy.png",
        "roi": [796, 318, 127, 112],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 6 Chapter END [36]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part6-Chapter36_Easy.png",
        "roi": [791, 266, 125, 96],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 7 Chapter END [71]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part7-Chapter71_Easy.png",
        "roi": [745, 263, 120, 97],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 8 Chapter END [33]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part8-Chapter33_Easy.png",
        "roi": [788, 337, 123, 76],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 9 Chapter END [33]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part9-Chapter33_Easy.png",
        "roi": [744, 274, 120, 70],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 10 Chapter END [33]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part10-Chapter33_Easy.png",
        "roi": [751, 249, 114, 90],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 11 Chapter END [36]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part11-Chapter36_Easy.png",
        "roi": [764, 325, 124, 91],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 12 Chapter END [15]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part12-Chapter15_Easy.png",
        "roi": [766, 328, 118, 78],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 13 Chapter END [35]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part13-Chapter35_Easy.png",
        "roi": [699, 334, 125, 95],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 14 Chapter END [65]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part14-Chapter65_Easy.png",
        "roi": [767, 326, 125, 79],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 15 Chapter END [95]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part15-Chapter95_Easy.png",
        "roi": [783, 262, 120, 76],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 16 Chapter END [133]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part16-Chapter133_Easy.png",
        "roi": [704, 336, 134, 88],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 17 Chapter END [166]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part17-Chapter166_Easy.png",
        "roi": [710, 318, 139, 93],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
        {
        "task_name": "Side-Story Part 17 HARD Chapter END [166]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part17-Chapter166_Hard.png",
        "roi": [710, 318, 139, 93],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 18 Chapter END [192]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part18-Chapter192_Easy.png",
        "roi": [769, 258, 139, 120],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 19 Chapter END [226]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part19-Chapter226_Easy.png",
        "roi": [796, 327, 102, 74],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 20 Chapter END [29]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part20-Chapter29_Easy.png",
        "roi": [752, 339, 128, 84],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 21 Chapter END [58]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part21-Chapter58_Easy.png",
        "roi": [753, 275, 99, 82],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 22 Chapter END [87]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part22-Chapter87_Easy.png",
        "roi": [775, 331, 109, 76],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5
    },
    {
        "task_name": "Side-Story Part 23 Chapter END [117] Final Part [Switch To Hard]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part23-Chapter117_Easy.png",
        "roi": [699, 324, 139, 115],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5,
    },

       {
        "task_name": "Side-Story Part 24 Chapter END [153] Final Part [Switch To Hard]",
        "type": "template",
        "template_path": "templates/Side-Story/S_Part24-Chapter153_Easy.png",
        "roi": [762, 328, 136, 92],
        "click_location_str": "76,480",
        "use_match_position": False,
        "confidence": 0.80,
        "priority": 5,
        "HardStory": True,
    },

]
```

## tasks/guild_tasks.py

```python
# tasks/guild_tasks.py - Complete guild tutorial and rejoin tasks

GUILD_TUTORIAL_TASKS = [
    {
        "task_name": "Click [Guild Icon]",
        "type": "template",
        "template_path": "templates/Guild/GuildIcon.png",
        "roi": [442, 430, 109, 108],
        "confidence": 0.70,
        "use_match_position": True,
        "isLogical": False,
        "priority": 15,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [Join]",
        "type": "pixel",
        "click_location_str": "814,173",
        "search_array": ["801,173","#fbfcff","807,87","#485563","860,88","#ffffff"],
        "isLogical": False,
        "priority": 20,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [OK]",
        "type": "template",
        "template_path": "templates/Guild/OKGUILD.png",
        "roi": [535, 386, 162, 49],
        "confidence": 0.80,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 25,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [Guild TOP]",
        "type": "template",
        "template_path": "templates/Guild/GuildTOP.png",
        "roi": [321, 337, 312, 59],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "priority": 30,
        "cooldown": 2.0,
    },
]

Guild_Rejoin = [
    {
        "task_name": "Click Join Button",
        "type": "template",
        "template_path": "templates/Guild/Join.png",
        "roi": [772, 116, 79, 399],
        "confidence": 0.80,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 15,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click Refresh",
        "type": "pixel",
        "click_location_str": "856,84",
        "search_array": ["859,88","#ffffff","861,78","#4d555c","876,100","#dedddd"],
        "isLogical": False,
        "priority": 10,  # Higher priority to refresh guild list
        "cooldown": 3.0,
    },
    {
        "task_name": "Click [Guild TOP]",
        "type": "template",
        "template_path": "templates/Guild/GuildTOP.png",
        "roi": [321, 337, 312, 59],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "NeedGuildTutorial": True,
        "priority": 25,
        "cooldown": 2.0,
    },
]
```

## tasks/hard_story.py

```python
# tasks/hard_story.py - Advanced Hard Story progression tasks

HardStory_Tasks = [
    {
        "task_name": "Part 24 [Side Story] Hard Finished [Switch To Sub Stories]",
        "type": "pixel",
        "click_location_str": "34,29",
        "search_array": ["537,344","#ff0000","918,42","#eb1a1a","506,364","#e9e902","486,148","#f5cd3d"],
        "isLogical": False,
        "priority": 1,
        "Sub-Stores": True
    },
    {
        "task_name": "Active Hard Mode If It Doesn't Activited",
        "type": "pixel",
        "click_location_str": "845,41",
        "search_array": ["921,42","#0a36e5","47,15","#010101","24,49","#e50012","81,32","#fefefe"],
        "isLogical": False,
        "priority": 20,
    },
    {
        "task_name": "Hard Mode Activited Let Swipe!",
        "type": "pixel",
        "click_location_str": "0,0",  # No click needed, just detection
        "search_array": ["921,40","#fe7272","47,15","#010101","24,49","#e50012","81,32","#fefefe"],
        "isLogical": True,
        "HardModeSwipe": True,  # Flag to identify this as hard mode swipe task
        "shared_detection": True,
        "priority": 20,
        "cooldown": 2.0,
    },
    {
        "task_name": "Let's Start With Part-1 HARD!",
        "type": "template",
        "template_path": "templates/Story_Mode_Hard/Part1_hard.png",
        "roi": [135, 113, 491, 290],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": True,
        "shared_detection": True,
        "priority": 20,
        "cooldown": 2.0,
        "BackToStory": True,
    },
        {
        "task_name": "Let's Start With Part-1 HARD! [Side Story]",
        "type": "template",
        "template_path": "templates/Story_Mode_Hard/S_Part1_hard.png",
        "roi": [10, 79, 949, 351],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": True,
        "shared_detection": True,
        "priority": 20,
        "cooldown": 2.0,
        "BackToStory": True,
    },

    
]
```

## tasks/main_tasks.py

```python
from .detect_chapter_end import DETECT_CHAPTER_END

Main_Tasks = [
    {
        "task_name": "Click Story MAP",
        "type": "template",
        "template_path": "templates/Story_Mode/StoryMAP.png",
        "roi": [3, 127, 956, 347],
        "confidence": 0.80,  # Increased from 0.75 to prevent false positives
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 30,
        "cooldown": 2.0,
    },
        {
        "task_name": "Click feetMap",
        "type": "template",
        "template_path": "templates/Story_Mode/feetMap.png",
        "roi": [3, 127, 956, 347],
        "confidence": 0.60,  # Increased from 0.75 to prevent false positives
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 30,
        "cooldown": 2.0,
    },
    {
        "task_name": "All Posibile Ways of Stars Map #1",
        "type": "template",
        "template_path": "templates/Story_Mode/Stars.png",
        "roi": [3, 86, 953, 415],
        "confidence": 0.70,
        "use_match_position": True,
        "FullyAnylaze": True,
        "isLogical": False,
        "shared_detection": True,
        "multi_click": True,  # Click all stars found
        "priority": 20,
        "cooldown": 3.0,
    },
    
    # Battle Preparation - Medium Priority

    
    # Quest Progression
    {
        "task_name": "Click White Tap Button",
        "type": "pixel",
        "click_location_str": "665,507",
        "search_array": ["917,13","#0e2988","671,500","#4e4e67"],
        "isLogical": False,
        "priority": 35,
        "cooldown": 0.5,  # Short cooldown for tap-to-continue
    },
   
    
    # Social/Cancel Actions - Lower Priority
    {
        "task_name": "Click [Cancel] For Friend Request",
        "type": "pixel",
        "click_location_str": "344,409",
        "search_array": ["720,121","#0d12b5","713,134","#e60012","489,175","#ffffff","565,174","#ffffff"],
        "isLogical": False,
        "priority": 50,
    },
    # Story Already Clear But Trying to Re Read
    {
        "task_name": "Click [Cancel] For Re-Read Story",
        "type": "pixel",
        "click_location_str": "343,374",
        "search_array": ["249,153","#0d12b5","259,163","#e60012","535,262","#ffffff","612,263","#ffffff","542,258","#ffffff"],
        "isLogical": False,
        "priority": 20,
    },
    
    # Chapter Navigation
    {
        "task_name": "Click Arrow If All Chapters Clear",
        "type": "template",
        "template_path": "templates/Story_Mode/NextStories.png",
        "roi": [856, 206, 102, 107],
        "confidence": 0.55,
        "use_match_position": True,
        "isLogical": False,
        "priority": 1,
        "cooldown": 2.0,
        "sleep": 8.5,
    },
    
    # Uncleared Content Selection
    # Uncleared Content Selection
    {
        "task_name": "Choose Uncleared Part",
        "type": "template",
        "template_path": "templates/Story_Mode/UnClearedPart.png",
        "roi": [5, 223, 952, 164],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "priority": 25,
        "cooldown": 2.0,
    },
        {
        "task_name": "Choose Uncleared Part",
        "type": "template",
        "template_path": "templates/Story_Mode/UnClearedPart2.png",
        "roi": [5, 223, 952, 164],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 25,
        "cooldown": 2.0,
    },
        # HARD MODE SWITCHER (STORY MODE FINISHED)
            {
        "task_name": "Part 21 Finished Detected",
        "type": "template",
        "template_path": "templates/Story_Mode/Part21_full.png",
        "roi": [308, 61, 648, 389],
        "confidence": 0.90,
        "isLogical": False,
        "HardStory": True,  # Switches to HardStory_tasks
        "priority": 5,  # <-- ADD THIS LINE
    },
            {
        "task_name": "Part 21 Finished Detected [Pixels]",
        "type": "pixel",
        "click_location_str": "0,0",
        "search_array": ["458,361","#ffff00","353,102","#009aff","373,274","#191925","424,269","#191925","434,273","#191925","480,360","#ffff00","506,364","#e9e902"],
        "isLogical": False,
        "HardStory": True,  # Switches to HardStory_tasks
        "priority": 5,  # <-- ADD THIS LINE,
    },


] +  DETECT_CHAPTER_END

```

## tasks/restarting_tasks.py

```python
# tasks/restarting_tasks.py - Complete tasks for game startup and initial navigation

Restarting_Tasks = [
        # From Restarting_Tasks to Main_Tasks
    {
        "task_name": "Open Story Window",
        "type": "pixel",
        "click_location_str": "531,193",
        "search_array": ["479,146","#ebebea","457,184","#ffffff","524,191","#ffffff"],
        "isLogical": False,
        "BackToStory": True,  # Switches to Main_Tasks
    },
    
    # HIGHEST PRIORITY - Error Recovery/Back Navigation (Priority 5-10)
    {
        "task_name": "Click[Back] In Selling Character Window",
        "type": "pixel",
        "click_location_str": "23,22",
        "search_array": ["216,512","#e24601","74,26","#ffffff","24,21","#ffffff","53,27","#ffffff"],
        "isLogical": False,
        "priority": 5,
        "cooldown": 2.0,
    },
    
    # HIGH PRIORITY - Game Start/Mod Menu (Priority 10-15)
    {
        "task_name": "Click [Thank You] For Mod Menu",
        "type": "pixel",
        "click_location_str": "434,470",
        "search_array": ["265,470","#1c262b","338,469","#ffffff"],
        "isLogical": False,
        "priority": 10,
        "cooldown": 3.0,
    },
    {
        "task_name": "Click [Game Start]",
        "type": "pixel",
        "click_location_str": "477,452",
        "search_array": ["880,490","#515151","937,512","#e60012"],
        "isLogical": False,
        "priority": 15,
        "cooldown": 3.0,
    },
    {
        "task_name": "Click [Game Start 2]",
        "type": "pixel",
        "click_location_str": "471,450",
        "search_array": ["845,505","#fdfdfd","856,513","#e81828","14,21","#ffffff"],
        "isLogical": False,
        "priority": 15,
        "cooldown": 3.0,
    },
    
    # MEDIUM PRIORITY - Quest/Event Handling (Priority 20-30)
    {
        "task_name": "Click [Yes] For Paused Quest Error",
        "type":"pixel",
        "click_location_str": "619,373",
        "search_array": ["251,153","#0d12b5","260,165","#e60012","432,151","#191925","239,224","#ffffff","368,227","#ffffff"],
        "isLogical": False,
        "priority": 20,
        "cooldown": 2.0,
    },
       {
        "task_name": "Click [Yes] For Continue Playing Quest",
        "type":"pixel",
        "click_location_str": "621,373",
        "search_array": ["246,154","#0d12b5","262,164","#e60012","430,276","#ffffff","471,275","#ffffff","496,275","#ffffff"],
        "isLogical": False,
        "priority": 20,
        "cooldown": 2.0,
    },
    {
        "task_name": "Exit News",
        "type": "template",
        "template_path": "templates/Restarting/Exit.png",
        "roi": [731, 0, 228, 133],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 25,
        "cooldown": 2.0,
    },
    
    # LOWER PRIORITY - Navigation/Menu Access (Priority 35-40)
    {
        "task_name": "Open [SOLO] Menu",
        "type": "template",
        "template_path": "templates/Restarting/Solo.png",
        "roi": [814, 420, 142, 118],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "priority": 35,
        "cooldown": 2.0,
    },
    
    # LOW PRIORITY - Login Bonuses (Priority 40-50)
    {
        "task_name": "Login Bonus Begginer",
        "type": "pixel",
        "click_location_str": "534,338",
        "search_array": ["195,93","#e50012","182,82","#0d12b4","334,79","#191925"],
        "isLogical": False,
        "priority": 40,
        "cooldown": 3.0,
    },
    {
        "task_name": "Login Bonus",
        "type": "pixel",
        "click_location_str": "626,510",
        "search_array": ["405,36","#191925","483,36","#191925","255,47","#e50012","255,35","#0d12b4"],
        "isLogical": False,
        "priority": 40,
        "cooldown": 3.0,
    },
    {
        "task_name": "Skip Any New Events/Windows Opened By Clicking [OK]",
        "type": "template",
        "template_path": "templates/Restarting/OK.png",
        "roi": [2, 285, 559, 244],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,  # Check with other UI elements
        "priority": 50,
        "cooldown": 2.0,
    },
]
```

## tasks/sell_characters_tasks.py

```python
# tasks/sell_characters_tasks.py - Complete tasks for selling excess characters

Sell_Characters = [
    # Navigation to character management
    {
        "task_name": "Go To Character List",
        "type": "template",
        "template_path": "templates/Sell_Characters/CharacterList.png",
        "roi": [174, 330, 607, 87],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "priority": 10,
        "cooldown": 2.0,
    },
        {
        "task_name": "Go To Character List #2",
        "type": "template",
        "template_path": "templates/Sell_Characters/CharacterList2.png",
        "roi": [497, 331, 252, 86],
        "confidence": 0.80,
        "use_match_position": True,
        "isLogical": False,
        "priority": 10,
        "cooldown": 2.0,
    },
    
    # Selling process - Sequential steps
    {
        "task_name": "Click [Sell]",
        "type": "pixel",
        "click_location_str": "153,515",
        "search_array": ["141,516","#eaeaea","168,515","#ffffff","132,513","#2b3a48"],
        "isLogical": False,
        "priority": 15,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [Multi Select]",
        "type": "pixel",
        "click_location_str": "319,511",
        "search_array": ["218,521","#ffbc2e","276,513","#d9dada","291,511","#f9f9fa","857,516","#16337d"],
        "isLogical": False,
        "priority": 20,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [All]",
        "type": "template",
        "template_path": "templates/Sell_Characters/All.png",
        "roi": [290, 276, 185, 171],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "priority": 25,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [3 Stars]",
        "type": "template",
        "template_path": "templates/Sell_Characters/3StarsSell.png",
        "roi": [370, 169, 115, 58],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,  # Check with other selection options
        "priority": 30,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [Select 50 Characters]",
        "type": "pixel",
        "click_location_str": "656,488",
        "search_array": ["473,207","#ec4d01","456,423","#ec4d01","458,314","#e94b01","472,208","#ee5001","769,492","#215af9","586,485","#0c3be2"],
        "isLogical": False,
        "priority": 35,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [Sell]",
        "type": "pixel",
        "click_location_str": "817,510",
        "search_array": ["806,509","#ffffff","832,510","#ffffff","859,506","#0a3ae1"],
        "isLogical": False,
        "priority": 40,
        "cooldown": 2.0,
    },
    
    # Confirmation steps
    {
        "task_name": "Click [OK To Sell]",
        "type": "pixel",
        "click_location_str": "621,486",
        "search_array": ["603,486","#ffffff","622,489","#ffffff","225,433","#191925","686,485","#0939e0"],
        "isLogical": False,
        "priority": 45,
        "cooldown": 3.0,  # Longer cooldown to ensure sale processes
    },
    {
        "task_name": "Click [Close]",
        "type": "template",
        "template_path": "templates/Sell_Characters/Close.png",
        "roi": [370, 169, 115, 58],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 50,
        "cooldown": 2.0,
    },
]
```

## tasks/shared_tasks.py

```python
# tasks/shared_tasks.py - Complete shared tasks with smart detection

Shared_Tasks = [
    # HIGHEST PRIORITY - Connection/Network Issues (Priority 1-5)
    {
        "task_name": "Connection Error - Retry-OutGame",
        "type": "template",
        "template_path": "templates/Shared/Retry_Connection_Blue.png",
        "roi": [64, 254, 888, 239],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 1,
        "cooldown": 5.0,  # Long cooldown to prevent connection spam
    },
    {
        "task_name": "Connection Error - Retry-InsideGame",
        "type": "template",
        "template_path": "templates/Shared/Retry_Connection_Red.png",
        "roi": [64, 254, 888, 239],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 1,
        "cooldown": 5.0,
    },
    {
        "task_name": "Click [Resume] When Game Stopped Randomly",
        "type": "template",
        "template_path": "templates/Shared/Resume.png",
        "roi": [592, 460, 165, 54],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 2,
        "cooldown": 3.0,
    },
       {
        "task_name": "Download Data [Game Update]",
        "type": "pixel",
        "click_location_str": "620,372",
        "search_array": ["385,152","#191925","522,153","#191925","574,156","#191925","701,165","#e60012","708,153","#0d12b5"],
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 1,
        "cooldown": 1.0,
    },
    
    # HIGH PRIORITY - UI Elements/Popups (Priority 5-10)
    {
        "task_name": "Click [Skip]",
        "type": "template",
        "template_path": "templates/Shared/Skip.png",
        "roi": [830, 1, 129, 59],
        "confidence": 0.70,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 5,
        "cooldown": 3.0,  # Prevent skip button spam
    },
    {
        "task_name": "Click [Close] for Hard Mode Unlocked",
        "type": "template",
        "template_path": "templates/Shared/Close.png",
        "roi": [326, 340, 302, 55],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "shared_detection": True,
        "priority": 8,
        "cooldown": 2.0,
    },
    
    # MEDIUM PRIORITY - Store/Purchase Actions (Priority 40-50)
    {
        "task_name": "Go To Purchase Tickets",
        "type": "template",
        "template_path": "templates/Purchase_Tickets/PurchaseTickets.png",
        "roi": [390, 341, 169, 55],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "priority": 40,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click 25 Tickets",
        "type": "template",
        "template_path": "templates/Purchase_Tickets/25Tickets.png",
        "roi": [194, 319, 564, 129],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "priority": 45,
        "cooldown": 2.0,
    },
    {
        "task_name": "Confirm Ticket Purchase",
        "type": "template",
        "template_path": "templates/Purchase_Tickets/Purchase.png",
        "roi": [534, 343, 174, 56],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "priority": 45,
        "cooldown": 2.0,
    },

        {
        "task_name": "Click [Prepare To Battle]",
        "type": "pixel",
        "click_location_str": "693,492",
        "search_array": ["527,486","#0c3be2","567,490","#ffffff","660,493","#ffffff","754,492","#ffffff"],
        "isLogical": False,
        "priority": 5,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [Start Quest]",
        "type": "pixel",
        "click_location_str": "715,497",
        "search_array": ["583,490","#ffffff","652,491","#0d3de4","671,498","#ffffff","735,496","#ffffff"],
        "isLogical": False,
        "priority": 5,
        "cooldown": 2.0,
    },

     {
        "task_name": "Click New Record Word To Open Next Quest Menu",
        "type": "pixel",
        "click_location_str": "449,503",
        "search_array": ["833,35","#ff0000","819,54","#ffffff","834,74","#ff0000"],
        "isLogical": False,
        "priority": 20,
    },
    {
        "task_name": "Click [Next Quest]",
        "type": "pixel",
        "click_location_str": "756,508",
        "search_array": ["713,512","#ffffff","760,507","#ffffff","698,496","#1e46f2"],
        "isLogical": False,
        "priority": 5,
    },
    {
        "task_name": "New Record Quest Obtained",
        "type": "pixel",
        "click_location_str": "478,281",
        "search_array": ["170,273","#fefefe","810,187","#ff0000","798,209","#ffffff"],
        "isLogical": False,
        "priority": 20,
    },
]
```

## tasks/side_story.py

```python
SideStory = [
    {
        "task_name": "Click [Side]",
        "type": "pixel",
        "click_location_str": "137,90",
        "search_array": ["121,78","#6e484d","187,74","#000000","212,74","#000000","227,69","#000000","253,72","#000000"],
        "isLogical": False,
        "priority": 1,
        "cooldown": 2.0,
        "BackToStory": True,
    },
        {
        "task_name": "Side Mode Is Already Acvitied",
        "type": "pixel",
        "click_location_str": "0,0",
        "search_array": ["116,120","#ffff00","99,70","#ffff00","144,75","#ffff00","115,79","#ffffff"],
        "isLogical": False,
        "priority": 2,
        "cooldown": 2.0,
        "BackToStory": True,
    },
] 
```

## tasks/sub_stories.py

```python

SubStories = [
        {
        "task_name": "Unclear Sub-Stories Map",
        "type": "template",
        "roi": [68, 4, 409, 533],
        "confidence": 0.80,
        "template_path": "templates/Sub-Stories/Sub-Storie-Map-UnClear.png",
        "priority": 1,
        "cooldown": 2.0,
    },
    {
        "task_name": "Leave [Story Mode Menu] For [Going To Sub-Stories]",
        "type": "pixel",
        "click_location_str": "25,20",
        "search_array": ["113,70","#ffff00","136,82","#750000","113,78","#ffffff","25,20","#ffffff"],
        "priority": 1,
        "cooldown": 2.0,
    },
    {
        "task_name": "Click [Sub-Stories]",
        "type": "pixel",
        "click_location_str": "694,189",
        "search_array": ["679,180","#ffffff","736,202","#ffffff","794,201","#9c1212","791,204","#9c1212"],
        "priority": 1,
        "cooldown": 2.0,
    },

    {

        "task_name": "Click [Sub-Stories MAP 1]",
        "type": "template",
        "template_path": "templates/Sub-Stories/Sub-Stories-1-New.png",
        "roi": [86, 103, 249, 176],
        "confidence": 0.90,
        "use_match_position": True,
        "multi_click": True,
        "priority": 20,
        "cooldown": 2.0,
    },
    {

        "task_name": "Click [Sub-Stories MAP 2]",
        "type": "template",
        "template_path": "templates/Sub-Stories/Sub-Stories-2-New.png",
        "roi": [352, 103, 255, 195],
        "confidence": 0.90,
        "use_match_position": True,
        "multi_click": True,
        "priority": 21,
        "cooldown": 2.0,
    },
    {

        "task_name": "Click [Sub-Stories MAP 3]",
        "type": "template",
        "template_path": "templates/Sub-Stories/Sub-Stories-3-New.png",
        "roi": [616, 100, 258, 200],
        "confidence": 0.90,
        "use_match_position": True,
        "multi_click": True,
        "priority": 22,
        "cooldown": 2.0,
    },
    {

        "task_name": "Click [Sub-Stories MAP 4]",
        "type": "template",
        "template_path": "templates/Sub-Stories/Sub-Stories-4-New.png",
        "roi": [215, 314, 261, 208],
        "confidence": 0.90,
        "use_match_position": True,
        "multi_click": True,
        "priority": 23,
        "cooldown": 2.0,
    },
    {

        "task_name": "Click [Sub-Stories MAP 5]",
        "type": "template",
        "template_path": "templates/Sub-Stories/Sub-Stories-5-New.png",
        "roi": [484, 316, 259, 198],
        "confidence": 0.90,
        "use_match_position": True,
        "multi_click": True,
        "priority": 24,
        "cooldown": 2.0,
    },
        {

        "task_name": "Choose Sub Storie Part To Complete",
        "type": "template",
        "template_path": "templates/Sub-Stories/NewPart.png",
        "roi": [130, 93, 709, 360],
        "confidence": 0.90,
        "use_match_position": True,
        "multi_click": True,
        "priority": 30,
        "cooldown": 2.0,
    },

        {
        "task_name": "Back To Missions of currently Sub Story",
        "type": "pixel",
        "search_array": ["146,504","#0b3be2","172,510","#ffffff","220,508","#ffffff"],
        "click_location_str": "751,507",
        "priority": 1,
        "cooldown": 2.0,
    },
    {
        "task_name": "Currently Story Detect All Maps Are Cleared! [Sub Stories]",
        "type": "pixel",
        "search_array": ["96,68","#3fc5ff","150,71","#159fff","158,71","#17a0ff"],
        "click_location_str": "483,500",
        "priority": 1,
        "CheckSubStoriesAllCleared": True,
        "cooldown": 2.0,
    },
   {
        "task_name": "Click [Close] For Prize",
        "type": "pixel",
        "search_array": ["723,34","#0d12b5","714,48","#e60012","612,491","#235df9"],
        "click_location_str": "488,487",
        "priority": 30,
        "cooldown": 2.0,
    },


]
```

## tasks/sub_stories_check.py

```python
SubStories_check = [

        {
        "task_name": "Not All Sub-Storiies sheet are clear",
        "type": "Pixel-OneOrMoreMatched",
        "pixel-values":["175,115","#ff4866","175,200","#ff4866","175,285","#ff4866","175,371","#ff4866","406,115","#ff4866","405,200","#ff4866","405,285","#ff4866","406,371","#ff4866","630,115","#ff4866","630,200","#ff4866","630,285","#ff4866","611,370","#ff4866"],
        "click_location_str": "694,189",
        "priority": 1,
        "KeepChecking": 5.0,
        "cooldown": 2.0,
        "Sub-Stores": True
    },

            {
        "task_name": "From Page 1 To Page 2",
        "type": "pixel",
        "search_array": ["338,488","#ec4d01","420,486","#3f4b58"],
        "click_location_str": "400,483",
        "priority": 20,
        "cooldown": 2.0,
        "Sub-Stores": True
    },
                {
        "task_name": "From Page 2 To Page 3",
        "type": "pixel",
        "search_array": ["420,488","#ec4d01","501,486","#3f4b58"],
        "click_location_str": "481,482",
        "priority": 21,
        "cooldown": 2.0,
        "Sub-Stores": True
    },
                    {
        "task_name": "From Page 3 To Page 4",
        "type": "pixel",
        "search_array": ["500,488","#ec4d01","663,486","#3f4b58"],
        "click_location_str": "562,484",
        "priority": 22,
        "cooldown": 2.0,
        "Sub-Stores": True
    },
                        {
        "task_name": "From Page 4 To Page 5",
        "type": "pixel",
        "search_array": ["578,488","#ec4d01","663,486","#3f4b58"],
        "click_location_str": "643,483",
        "priority": 23,
        "cooldown": 2.0,
        "Sub-Stores": True
    },
                        {
        "task_name": "Last Page No Pages Left",
        "type": "Pixel-OneOrMoreMatched",
        "pixel-values":["662,488","#ec4d01","578,488","#ec4d01","500,488","#ec4d01","420,488","#ec4d01"],
        "click_location_str": "25,21",
        "priority": 25,
        "KeepChecking": 5.0,
        "cooldown": 2.0,
        "Sub-Stores": True
    }
]
```

## tasks/switcher_tasks.py

```python
# tasks/switcher_tasks.py - Tasks responsible for switching between task sets

Switcher_Tasks = [
        # STORY COMPLETED LET'S Back To Restarting SO WE CAN RESTART THE GAME
    {
        "task_name": "Story Completed",
        "type": "pixel",
        "click_location_str": "482,373",
        "search_array": ["395,155","#191925","460,152","#191925","567,155","#191925","263,154","536,153","#191925","#0d12b5","265,166","#e60012"],
        "isLogical": False,
        "shared_detection": True,
        "priority": 1,
        "cooldown": 3.0,
        "BackToRestarting": True,
    },
    # From Restarting_Tasks to GUILD_TUTORIAL_TASKS
    {
        "task_name": "Guild Tutorial Detected",
        "type": "template",
        "template_path": "templates/Switcher/ArrowShowedUP.png",
        "roi": [470, 365, 76, 104],
        "confidence": 0.60,
        "use_match_position": False,
        "isLogical": False,
        "NeedGuildTutorial": True,  # Switches to GUILD_TUTORIAL_TASKS
    },
    
    # From any task set to Sell_Characters when characters are full
    {
        "task_name": "Character FULL",
        "type": "pixel",
        "click_location_str": "0,0",  # No click needed, just detection
        "search_array": ["254,151","#0d12b5","268,162","#e60012","255,252","#ffffff","299,251","#ffffff","356,254","#ffffff","432,149","#191919"],
        "isLogical": False,
        "Characters_Full": True,  # Switches to Sell_Characters
        "ShowsIn": ["main_tasks", "restarting_tasks"],  # Only active in these task sets
    },
        {
        "task_name": "Character FULL #2",
        "type": "pixel",
        "click_location_str": "0,0",  # No click needed, just detection
        "search_array": ["257,154","#0d12b5","262,164","#e60012","491,236","#ffffff","591,237","#ffffff"],
        "isLogical": False,
        "Characters_Full": True,  # Switches to Sell_Characters
        "ShowsIn": ["main_tasks", "restarting_tasks"],  # Only active in these task sets
    },
    
    # From GUILD_TUTORIAL_TASKS to Guild_Rejoin
    {
        "task_name": "Click [OK] For GUILD limit Reached",
        "type": "pixel",
        "click_location_str": "481,372",
        "search_array": ["240,154","#0d12b5","259,165","#e60012","450,153","#191925","505,156","#191925"],
        "isLogical": False,
        "NeedToRejoin": True,  # Switches to Guild_Rejoin
    },
    
    # From Guild_Rejoin back to GUILD_TUTORIAL_TASKS
    {
        "task_name": "Click [Guild TOP] After Rejoin",
        "type": "template",
        "template_path": "templates/Guild/GuildTOP.png",
        "roi": [321, 337, 312, 59],
        "confidence": 0.90,
        "use_match_position": True,
        "isLogical": False,
        "isRefreshed": True,  # Returns to GUILD_TUTORIAL_TASKS
    },
    
    # From GUILD_TUTORIAL_TASKS back to Restarting_Tasks
    {
        "task_name": "Back To Main Menu From Guild",
        "type": "pixel",
        "click_location_str": "31,28",
        "search_array": ["792,494","#e6f6f2","517,501","#eeeef2"],
        "isLogical": False,
        "BackToRestartingTasks": True,  # Switches to Restarting_Tasks
    },
    
    # From Sell_Characters back to Restarting_Tasks
    {
        "task_name": "Characters Are Sold [No More Left]",
        "type": "pixel",
        "click_location_str": "315,490",
        "search_array": ["684,487","#7f0000","457,421","#e64801","461,313","#e64801","473,206","#e94b01"],
        "isLogical": False,
        "BackToRestartingTasks": True,  # Switches to Restarting_Tasks
    },

]
```

## actions.py

```python
# actions.py - Enhanced Version with OCR Support
import asyncio
import subprocess
import io
import time
from typing import Dict, List, Tuple, Optional, Set
from dataclasses import dataclass
import os
from collections import defaultdict

import numpy as np
from PIL import Image
import cv2
from screenrecord_manager import get_screenrecord_manager, cleanup_all_screenrecord

# OCR imports
try:
    import pytesseract
    TESSERACT_AVAILABLE = True
    # Configure Tesseract path for Windows (adjust as needed)
    # pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
except ImportError:
    print("[OCR] Tesseract not available - OCR features disabled")
    TESSERACT_AVAILABLE = False

try:
    import easyocr
    # Initialize EasyOCR reader (supports multiple languages)
    ocr_reader = easyocr.Reader(['en'], gpu=True)  # Use GPU if available
    EASYOCR_AVAILABLE = True
except ImportError:
    print("[OCR] EasyOCR not available - falling back to Tesseract")
    EASYOCR_AVAILABLE = False
    ocr_reader = None

# PyAutoGUI import with headless environment handling
try:
    import pyautogui
    pyautogui.FAILSAFE = False
    PYAUTOGUI_AVAILABLE = True
except ImportError:
    print("[MATCHING] PyAutoGUI not available - using OpenCV fallback")
    PYAUTOGUI_AVAILABLE = False
except Exception as e:
    print(f"[MATCHING] PyAutoGUI import issue: {e}")
    PYAUTOGUI_AVAILABLE = False

# --- Screenshot Cache ---
@dataclass
class ScreenshotCache:
    """Caches screenshots to avoid redundant captures"""
    image: np.ndarray
    timestamp: float
    
class ScreenshotManager:
    def __init__(self, cache_duration: float = 0.1):
        self.cache: Dict[str, ScreenshotCache] = {}
        self.cache_duration = cache_duration
        self.locks: Dict[str, asyncio.Lock] = {}
        self.streaming_enabled = False
    
    async def get_screenshot(self, device_id: str) -> Optional[np.ndarray]:
        """Get screenshot using ADB screencap with caching"""
        if device_id not in self.locks:
            self.locks[device_id] = asyncio.Lock()
        
        async with self.locks[device_id]:
            current_time = time.time()
            
            # Check cache
            if device_id in self.cache:
                cached = self.cache[device_id]
                if current_time - cached.timestamp < self.cache_duration:
                    return cached.image
            
            img = await self._capture_screenshot_adb(device_id)
            
            if img is not None:
                self.cache[device_id] = ScreenshotCache(img, current_time)
            return img
    
    async def _capture_screenshot_adb(self, device_id: str) -> Optional[np.ndarray]:
        """Capture screenshot using ADB (fallback)"""
        try:
            command = f"adb -s {device_id} exec-out screencap -p"
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if not stdout:
                return None
            
            pil_image = Image.open(io.BytesIO(stdout)).convert('RGB')
            return np.asarray(pil_image)
            
        except Exception as e:
            print(f"ADB screenshot failed for {device_id}: {e}")
            return None

# Global screenshot manager
screenshot_manager = ScreenshotManager()

# --- Template Cache ---
class TemplateCache:
    """Cache for template images to avoid repeated loading"""
    def __init__(self):
        self.templates: Dict[str, np.ndarray] = {}
        self.cache_size_limit = 50
    
    def get_template(self, template_path: str) -> Optional[np.ndarray]:
        """Load and cache template image"""
        if template_path in self.templates:
            return self.templates[template_path]
        
        if not os.path.exists(template_path):
            print(f"Template not found: {template_path}")
            return None
        
        try:
            template = cv2.imread(template_path, cv2.IMREAD_COLOR)
            if template is None:
                return None
            
            template = cv2.cvtColor(template, cv2.COLOR_BGR2RGB)
            
            if len(self.templates) >= self.cache_size_limit:
                self.templates.pop(next(iter(self.templates)))
            
            self.templates[template_path] = template
            return template
        except Exception as e:
            print(f"Error loading template {template_path}: {e}")
            return None

template_cache = TemplateCache()

# --- OCR Functions ---
class OCRManager:
    """Manages OCR operations with caching and optimization"""
    
    def __init__(self):
        self.ocr_cache: Dict[str, Dict] = {}  # Cache OCR results
        self.cache_duration = 0.5  # OCR cache duration in seconds
        
    async def extract_text_from_region(self, screenshot: np.ndarray, 
                                      roi: Tuple[int, int, int, int],
                                      use_easyocr: bool = True) -> List[Tuple[str, Tuple[int, int]]]:
        """
        Extract text from a specific region of the screenshot.
        Returns list of (text, center_position) tuples.
        """
        x, y, w, h = roi
        roi_img = screenshot[y:y+h, x:x+w]
        
        if roi_img.size == 0:
            return []
        
        detected_texts = []
        
        try:
            if use_easyocr and EASYOCR_AVAILABLE:
                # Use EasyOCR for better accuracy
                results = ocr_reader.readtext(roi_img, detail=1)
                
                for (bbox, text, confidence) in results:
                    if confidence > 0.5:  # Filter low confidence
                        # Calculate center position
                        min_x = min(pt[0] for pt in bbox)
                        max_x = max(pt[0] for pt in bbox)
                        min_y = min(pt[1] for pt in bbox)
                        max_y = max(pt[1] for pt in bbox)
                        
                        center_x = x + (min_x + max_x) // 2
                        center_y = y + (min_y + max_y) // 2
                        
                        detected_texts.append((text.lower(), (center_x, center_y)))
                        
            elif TESSERACT_AVAILABLE:
                # Use Tesseract as fallback
                # Preprocess image for better OCR
                gray = cv2.cvtColor(roi_img, cv2.COLOR_RGB2GRAY)
                
                # Apply threshold to get black text on white background
                _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
                
                # Get OCR data with positions
                data = pytesseract.image_to_data(thresh, output_type=pytesseract.Output.DICT)
                
                for i in range(len(data['text'])):
                    text = data['text'][i].strip().lower()
                    conf = int(data['conf'][i])
                    
                    if text and conf > 50:  # Filter empty and low confidence
                        box_x = data['left'][i]
                        box_y = data['top'][i]
                        box_w = data['width'][i]
                        box_h = data['height'][i]
                        
                        center_x = x + box_x + box_w // 2
                        center_y = y + box_y + box_h // 2
                        
                        detected_texts.append((text, (center_x, center_y)))
            
        except Exception as e:
            print(f"OCR error: {e}")
        
        return detected_texts
    
    async def find_text_in_region(self, screenshot: np.ndarray,
                                 search_texts: List[str],
                                 roi: Tuple[int, int, int, int]) -> Optional[Tuple[str, Tuple[int, int]]]:
        """
        Find any of the search texts in the specified region.
        Returns (matched_text, position) or None.
        """
        detected_texts = await self.extract_text_from_region(screenshot, roi)
        
        for search_text in search_texts:
            search_lower = search_text.lower().strip()
            
            for detected_text, position in detected_texts:
                # Check for exact match or substring match
                if search_lower in detected_text or detected_text in search_lower:
                    return (search_text, position)
        
        return None

# Global OCR manager
ocr_manager = OCRManager()

# --- Enhanced Task Execution Tracker ---
class TaskExecutionTracker:
    """Advanced tracker to prevent task spam and manage execution timing"""
    def __init__(self):
        self.last_execution: Dict[str, Dict[str, float]] = {}
        self.execution_count: Dict[str, Dict[str, int]] = {}
        self.cooldowns: Dict[str, float] = {}
        self.frame_tasks: Dict[str, Set[str]] = {}
        self.last_frame_time: Dict[str, float] = {}
        
    def set_task_cooldown(self, task_name: str, cooldown: float):
        """Set cooldown for a specific task"""
        self.cooldowns[task_name] = cooldown
    
    def can_execute_task(self, device_id: str, task_name: str, 
                         default_cooldown: float = 2.0) -> bool:
        """Check if task can be executed based on cooldowns and frame limits"""
        current_time = time.time()
        
        if device_id not in self.last_execution:
            self.last_execution[device_id] = {}
            self.execution_count[device_id] = {}
            self.frame_tasks[device_id] = set()
            self.last_frame_time[device_id] = 0
        
        if current_time - self.last_frame_time[device_id] > 0.1:
            self.frame_tasks[device_id] = set()
            self.last_frame_time[device_id] = current_time
        
        if task_name in self.frame_tasks[device_id]:
            return False
        
        last_time = self.last_execution[device_id].get(task_name, 0)
        cooldown = self.cooldowns.get(task_name, default_cooldown)
        
        if current_time - last_time < cooldown:
            return False
        
        return True
    
    def record_execution(self, device_id: str, task_name: str):
        """Record that a task was executed"""
        current_time = time.time()
        
        if device_id not in self.last_execution:
            self.last_execution[device_id] = {}
            self.execution_count[device_id] = {}
            self.frame_tasks[device_id] = set()
        
        self.last_execution[device_id][task_name] = current_time
        self.execution_count[device_id][task_name] = \
            self.execution_count[device_id].get(task_name, 0) + 1
        self.frame_tasks[device_id].add(task_name)
    
    def get_execution_count(self, device_id: str, task_name: str) -> int:
        """Get how many times a task has been executed"""
        if device_id not in self.execution_count:
            return 0
        return self.execution_count[device_id].get(task_name, 0)

# Global task tracker
task_tracker = TaskExecutionTracker()

# --- Smart Template Matching Functions ---
async def find_all_templates_smart(screenshot: np.ndarray, 
                                  templates_to_check: List[Tuple[str, Tuple[int, int, int, int], float]],
                                  min_distance: int = 30) -> Dict[str, List[Tuple[int, int]]]:
    """
    Find all instances of multiple templates in a single screenshot.
    Returns dict of template_path -> list of (x, y) positions
    """
    all_matches = {}
    
    for template_path, roi, confidence in templates_to_check:
        try:
            template = template_cache.get_template(template_path)
            if template is None:
                continue
            
            x, y, w, h = roi
            roi_img = screenshot[y:y+h, x:x+w]
            
            if roi_img.size == 0:
                continue
            
            result = cv2.matchTemplate(roi_img.astype(np.uint8), 
                                     template.astype(np.uint8), 
                                     cv2.TM_CCOEFF_NORMED)
            
            locations = np.where(result >= confidence)
            
            if len(locations[0]) == 0:
                continue
            
            matches = []
            template_h, template_w = template.shape[:2]
            
            for pt_y, pt_x in zip(locations[0], locations[1]):
                center_x = x + pt_x + template_w // 2
                center_y = y + pt_y + template_h // 2
                
                is_duplicate = False
                for existing_x, existing_y in matches:
                    dist_sq = (center_x - existing_x)**2 + (center_y - existing_y)**2
                    if dist_sq < min_distance**2:
                        is_duplicate = True
                        break
                
                if not is_duplicate:
                    matches.append((center_x, center_y))
            
            if matches:
                all_matches[template_path] = matches
                
        except Exception as e:
            print(f"Error matching template {template_path}: {e}")
            continue
    
    return all_matches

async def batch_check_pixels_enhanced(device_id: str, tasks: List[dict], 
                                     screenshot: Optional[np.ndarray] = None) -> List[dict]:
    """Enhanced batch checking with OCR support"""
    if screenshot is not None:
        img_gpu = screenshot
    else:
        img_gpu = await screenshot_manager.get_screenshot(device_id)
    
    if img_gpu is None:
        return []
    
    # Separate tasks by detection type
    pixel_tasks = []
    template_tasks = []
    ocr_tasks = []
    shared_detection_tasks = []
    
    for task in tasks:
        task_type = task.get("type", "pixel")
        
        if task_type == "pixel":
            pixel_tasks.append(task)
        elif task_type == "ocr":
            ocr_tasks.append(task)
        elif task_type == "template":
            if task.get("shared_detection", False):
                shared_detection_tasks.append(task)
            else:
                template_tasks.append(task)
    
    matched_tasks = []
    
    # Process pixel tasks
    for task in pixel_tasks:
        search_array = task["search_array"]
        all_match = True
        
        for i in range(0, len(search_array), 2):
            coords_str, hex_color = search_array[i], search_array[i+1]
            x, y = map(int, coords_str.split(','))
            
            expected_rgb = hex_to_rgb(hex_color)
            expected_rgb_gpu = np.array(expected_rgb)
            
            if 0 <= y < img_gpu.shape[0] and 0 <= x < img_gpu.shape[1]:
                pixel_color_gpu = img_gpu[y, x]
                if not np.array_equal(pixel_color_gpu, expected_rgb_gpu):
                    all_match = False
                    break
            else:
                all_match = False
                break
        
        if all_match:
            if task_tracker.can_execute_task(device_id, task["task_name"]):
                matched_tasks.append(task)
    
    # Process Pixel-OneOrMoreMatched tasks
    pixel_one_or_more_tasks = [task for task in tasks if task.get("type") == "Pixel-OneOrMoreMatched"]
    
    for task in pixel_one_or_more_tasks:
        pixel_values = task.get("pixel-values", [])
        if len(pixel_values) < 4:  # Need at least 2 pairs (coord, color, coord, color)
            continue
            
        match_found = False
        
        # Check consecutive pairs: (coord1, color1, coord2, color2), (color1, coord2, color2, coord3), etc.
        for i in range(0, len(pixel_values) - 3, 2):
            try:
                # Get first pair
                coords1_str = pixel_values[i]
                color1 = pixel_values[i + 1]
                
                # Get second pair  
                coords2_str = pixel_values[i + 2]
                color2 = pixel_values[i + 3]
                
                # Parse coordinates
                x1, y1 = map(int, coords1_str.split(','))
                x2, y2 = map(int, coords2_str.split(','))
                
                # Convert colors to RGB
                expected_rgb1 = hex_to_rgb(color1)
                expected_rgb2 = hex_to_rgb(color2)
                expected_rgb1_gpu = np.array(expected_rgb1)
                expected_rgb2_gpu = np.array(expected_rgb2)
                
                # Check if both pixels are within bounds and match
                if (0 <= y1 < img_gpu.shape[0] and 0 <= x1 < img_gpu.shape[1] and
                    0 <= y2 < img_gpu.shape[0] and 0 <= x2 < img_gpu.shape[1]):
                    
                    pixel_color1 = img_gpu[y1, x1]
                    pixel_color2 = img_gpu[y2, x2]
                    
                    if (np.array_equal(pixel_color1, expected_rgb1_gpu) and 
                        np.array_equal(pixel_color2, expected_rgb2_gpu)):
                        match_found = True
                        break
                        
            except (ValueError, IndexError):
                continue
        
        if match_found:
            if task_tracker.can_execute_task(device_id, task["task_name"]):
                matched_tasks.append(task)
    
    # Process OCR tasks
    for task in ocr_tasks:
        ocr_text = task.get("ocr_text", "")
        if not ocr_text:
            continue
        
        # Parse search texts (comma-separated)
        search_texts = [text.strip().lower() for text in ocr_text.split(",")]
        
        roi = task.get("roi", [0, 0, img_gpu.shape[1], img_gpu.shape[0]])
        
        # Check if we can execute this task
        if not task_tracker.can_execute_task(device_id, task["task_name"]):
            continue
        
        # Find text in region
        result = await ocr_manager.find_text_in_region(img_gpu, search_texts, roi)
        
        if result:
            matched_text, position = result
            task_copy = task.copy()
            
            # Handle position setting
            if task.get("use_match_position", False):
                # Only for single word/number searches (no comma)
                if "," not in ocr_text:
                    task_copy["click_location_str"] = f"{position[0]},{position[1]}"
                    task_copy["task_name"] = f"{task['task_name']} [OCR: '{matched_text}' at {position}]"
                else:
                    task_copy["task_name"] = f"{task['task_name']} [OCR: '{matched_text}' found]"
            else:
                task_copy["task_name"] = f"{task['task_name']} [OCR: '{matched_text}']"
            
            matched_tasks.append(task_copy)
            task_tracker.record_execution(device_id, task["task_name"])
    
    # Process shared detection templates
    if shared_detection_tasks:
        templates_to_check = []
        task_map = {}
        
        for task in shared_detection_tasks:
            template_paths = task.get("template_paths", [])
            if task.get("template_path"):
                template_paths = [task["template_path"]]
            
            roi = task.get("roi", [0, 0, img_gpu.shape[1], img_gpu.shape[0]])
            confidence = task.get("confidence", 0.9)
            
            for template_path in template_paths:
                templates_to_check.append((template_path, roi, confidence))
                task_map[template_path] = task
        
        all_matches = await find_all_templates_smart(img_gpu, templates_to_check)
        
        for template_path, positions in all_matches.items():
            task = task_map[template_path]
            task_name = task["task_name"]
            
            if not task_tracker.can_execute_task(device_id, task_name):
                continue
            
            if task.get("multi_click", False) or "UnClear" in task_name:
                print(f"[MULTI-DETECT] {task_name}: Found {len(positions)} matches")
                for i, (x, y) in enumerate(positions):
                    await execute_tap(device_id, f"{x},{y}")
                    await asyncio.sleep(0.05)
                
                task_tracker.record_execution(device_id, task_name)
                task_copy = task.copy()
                task_copy["task_name"] = f"{task_name} [Multi: {len(positions)} clicks]"
                matched_tasks.append(task_copy)
            else:
                if positions:
                    x, y = positions[0]
                    task_copy = task.copy()
                    task_copy["click_location_str"] = f"{x},{y}"
                    task_copy["use_match_position"] = True
                    matched_tasks.append(task_copy)
                    task_tracker.record_execution(device_id, task_name)
    
    # Process regular template tasks
    for task in template_tasks:
        task_name = task["task_name"]
        
        if not task_tracker.can_execute_task(device_id, task_name):
            continue
        
        template_paths = task.get("template_paths", [])
        if task.get("template_path"):
            template_paths = [task["template_path"]]
        
        roi = task.get("roi", [0, 0, img_gpu.shape[1], img_gpu.shape[0]])
        confidence = task.get("confidence", 0.9)
        
        match_found = False
        for template_path in template_paths:
            match_pos = await find_template_in_region(img_gpu, template_path, roi, confidence)
            if match_pos:
                task_copy = task.copy()
                if task.get("use_match_position", False):
                    task_copy["click_location_str"] = f"{match_pos[0]},{match_pos[1]}"
                matched_tasks.append(task_copy)
                task_tracker.record_execution(device_id, task_name)
                match_found = True
                break
        
        if match_found:
            break
    
    return matched_tasks

# Helper functions
def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]:
    """Converts a hex color string to an (R, G, B) tuple."""
    hex_color = hex_color.lstrip('#')
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

async def run_adb_command(command: str, device_id: Optional[str] = None) -> bytes:
    """Optimized ADB command execution"""
    full_command = f"adb -s {device_id} {command}" if device_id else f"adb {command}"
    
    process = await asyncio.create_subprocess_shell(
        full_command,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    
    stdout, stderr = await process.communicate()
    return stdout

async def execute_tap(device_id: str, location_str: str):
    """Execute tap command asynchronously"""
    coords = location_str.replace(',', ' ')
    await run_adb_command(f"shell input tap {coords}", device_id)

async def execute_swipe(device_id: str, x1: int, y1: int, x2: int, y2: int, duration: int):
    """Execute swipe command asynchronously"""
    await run_adb_command(f"shell input swipe {x1} {y1} {x2} {y2} {duration}", device_id)

async def find_template_in_region(screenshot: np.ndarray, template_path: str, 
                                 roi: Tuple[int, int, int, int], 
                                 confidence: float = 0.9) -> Optional[Tuple[int, int]]:
    """Find template in a specific region of the screenshot."""
    try:
        template = template_cache.get_template(template_path)
        if template is None:
            return None
        
        x, y, w, h = roi
        roi_img = screenshot[y:y+h, x:x+w]
        
        if roi_img.size == 0:
            return None
        
        result = cv2.matchTemplate(roi_img.astype(np.uint8), 
                                  template.astype(np.uint8), 
                                  cv2.TM_CCOEFF_NORMED)
        
        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)
        
        if max_val >= confidence:
            template_h, template_w = template.shape[:2]
            center_x = x + max_loc[0] + template_w // 2
            center_y = y + max_loc[1] + template_h // 2
            return (center_x, center_y)
        
        return None
        
    except Exception as e:
        print(f"Template matching error: {e}")
        return None

# Configure default cooldowns
task_tracker.set_task_cooldown("Click [Skip]", 3.0)
task_tracker.set_task_cooldown("Connection Error - Retry", 5.0)
task_tracker.set_task_cooldown("Click [OK]", 2.0)

# Export the enhanced batch check function
batch_check_pixels = batch_check_pixels_enhanced
```

## background_process.py

```python
# background_process.py - Enhanced with JSON flag support
import asyncio
import time
from typing import Optional, Dict, List, Set
from datetime import datetime
from collections import defaultdict

# Suppress warnings before importing OpenCV-related modules
from suppress_warnings import suppress_libpng_warning, suppress_stdout_stderr
suppress_libpng_warning()

import settings
from actions import batch_check_pixels_enhanced, execute_tap, screenshot_manager, run_adb_command, task_tracker
from device_state_manager import device_state_manager
from tasks import (
    Main_Tasks, 
    Restarting_Tasks, 
    Shared_Tasks, 
    Switcher_Tasks,
    GUILD_TUTORIAL_TASKS,
    Guild_Rejoin,
    Sell_Characters,
    HardStory_Tasks,
    SideStory,
    SubStories,
    SubStories_check
)

# Bleach game package name
BLEACH_PACKAGE_NAME = "com.klab.bleach"
BLEACH_ACTIVITY_NAME = "com.klab.bleach.MainActivity"


class ProcessMonitor:
    """Monitors game processes and manages task switching with state persistence"""
    
    def __init__(self):
        self.device_process_states = {}
        self.check_interval = 10
        self.last_check_times = {}
        self.active_task_set = {}
        self.initial_setup_complete = {}
        self.last_action_time = {}
        self.action_count = {}
        self.last_action_name = {}
        
    async def is_bleach_running(self, device_id: str) -> bool:
        """Check if Bleach Brave Souls process is running on the device"""
        try:
            command = f"shell pidof {BLEACH_PACKAGE_NAME}"
            result = await run_adb_command(command, device_id)
            return bool(result.strip())
        except Exception as e:
            print(f"[{device_id}] Error checking process")
            return False
    
    async def launch_bleach(self, device_id: str):
        """Launch Bleach Brave Souls game"""
        try:
            print(f"[{device_id}] Launching game...")
            command = f"shell monkey -p {BLEACH_PACKAGE_NAME} -c android.intent.category.LAUNCHER 1"
            await run_adb_command(command, device_id)
            await asyncio.sleep(3)
        except Exception as e:
            print(f"[{device_id}] Error launching game")
    
    async def kill_and_restart_game(self, device_id: str):
        """Kill and restart the game with force stop"""
        try:
            print(f"[{device_id}] Restarting game...")
            await run_adb_command(f"shell am force-stop {BLEACH_PACKAGE_NAME}", device_id)
            await asyncio.sleep(2)
            await self.launch_bleach(device_id)
            
            # Increment restarting count in device state
            device_state_manager.increment_counter(device_id, "RestartingCount")
            
            # Set to restarting tasks initially
            self.set_active_tasks(device_id, "restarting")
            self.reset_action_tracking(device_id)
        except Exception as e:
            print(f"[{device_id}] Error restarting game")
    
    def reset_action_tracking(self, device_id: str):
        """Reset action tracking for a device"""
        self.last_action_time[device_id] = time.time()
        self.action_count[device_id] = {}
        self.last_action_name[device_id] = None
    
    def track_action(self, device_id: str, action_name: str) -> bool:
        """Track action and check for repetition. Returns True if should restart"""
        current_time = time.time()
        
        if device_id not in self.last_action_time:
            self.last_action_time[device_id] = current_time
            self.action_count[device_id] = {}
            self.last_action_name[device_id] = None
        
        # Check for 240 second inactivity
        if current_time - self.last_action_time[device_id] > 240:
            print(f"[{device_id}] No actions for 240s - restart needed")
            return True
        
        self.last_action_time[device_id] = current_time
        
        # Track repetition
        if action_name not in self.action_count[device_id]:
            self.action_count[device_id][action_name] = 0
        
        if self.last_action_name[device_id] == action_name:
            self.action_count[device_id][action_name] += 1
            
            max_repetitions = 5 if "template" in action_name.lower() else 10
            
            if self.action_count[device_id][action_name] >= max_repetitions:
                print(f"[{device_id}] Task repeated {max_repetitions}x - restart needed")
                return True
        else:
            self.action_count[device_id][action_name] = 1
            self.last_action_name[device_id] = action_name
        
        # Update session stats
        device_state_manager.update_session_stats(device_id, action_name)
        
        return False
    
    async def should_check_process(self, device_id: str) -> bool:
        """Determine if it's time to check the process status"""
        current_time = time.time()
        
        if device_id not in self.last_check_times:
            self.last_check_times[device_id] = 0
        
        time_since_last_check = current_time - self.last_check_times[device_id]
        
        if time_since_last_check >= self.check_interval:
            self.last_check_times[device_id] = current_time
            return True
        
        return False
    
    def should_skip_task(self, device_id: str, task: dict) -> bool:
        """Check if a task should be skipped based on StopSupport flag"""
        stop_support = task.get("StopSupport")
        if stop_support:
            return device_state_manager.check_stop_support(device_id, stop_support)
        return False
    
    def get_active_tasks(self, device_id: str) -> List[dict]:
        """Get the currently active task set with shared and switcher tasks, filtered by StopSupport"""
        task_set = self.active_task_set.get(device_id, "restarting")
        
        task_map = {
            "main": Main_Tasks,
            "restarting": Restarting_Tasks,
            "guild_tutorial": GUILD_TUTORIAL_TASKS,
            "guild_rejoin": Guild_Rejoin,
            "sell_characters": Sell_Characters,
            "hardstory": HardStory_Tasks,
            "sidestory": SideStory,
            "substories": SubStories,
            "substories_check": SubStories_check
        }
        
        base_tasks = task_map.get(task_set, Restarting_Tasks)
        
        # Combine base tasks with shared tasks and switcher tasks
        all_tasks = base_tasks + Shared_Tasks + Switcher_Tasks
        
        # Filter out tasks with StopSupport flag if condition is met
        filtered_tasks = []
        for task in all_tasks:
            if not self.should_skip_task(device_id, task):
                filtered_tasks.append(task)
        
        # Sort by priority (lower number = higher priority)
        return sorted(filtered_tasks, key=lambda x: x.get('priority', 999))
    
    def set_active_tasks(self, device_id: str, task_set: str):
        """Set the active task set for a device and update state"""
        valid_sets = ["main", "restarting", "guild_tutorial", "guild_rejoin", "sell_characters", "hardstory", "sidestory", "substories", "substories_check"]
        if task_set in valid_sets:
            self.active_task_set[device_id] = task_set
            
            # Update current task set in device state
            device_state_manager.update_state(device_id, "CurrentTaskSet", task_set)
            
            task_names = {
                "main": "Main",
                "restarting": "Restarting",
                "guild_tutorial": "Guild Tutorial",
                "guild_rejoin": "Guild Rejoin",
                "sell_characters": "Sell Characters",
                "hardstory": "Hard Story",
                "sidestory": "Side Story",
                "substories": "Sub Stories",
                "substories_check": "Sub Stories Check"
            }
            print(f"[{device_id}] → {task_names.get(task_set, task_set)}")
    
    def is_initial_setup_needed(self, device_id: str) -> bool:
        """Checks if the initial setup logic needs to run for a device."""
        return not self.initial_setup_complete.get(device_id, False)
    
    def mark_initial_complete(self, device_id: str):
        """Marks that the initial setup for a device is complete."""
        self.initial_setup_complete[device_id] = True
    
    def should_use_saved_mode(self, device_id: str, current_task_set: str) -> str:
        """Check if we should switch to a different mode based on saved state"""
        if current_task_set == "restarting":
            recommended_mode = device_state_manager.should_skip_to_mode(device_id)
            if recommended_mode != "main":
                print(f"[{device_id}] State: Jumping to {recommended_mode}")
                return recommended_mode
        
        return current_task_set


class OptimizedBackgroundMonitor:
    def __init__(self):
        self.stop_event = asyncio.Event()
        self.check_interval = getattr(settings, 'BACKGROUND_CHECK_INTERVAL', 0.2)
        self.batch_size = getattr(settings, 'TASK_BATCH_SIZE', 20)
        self.device_states = {}
        self.parallel_screenshots = getattr(settings, 'PARALLEL_SCREENSHOT_CAPTURE', True)
        self.max_concurrent_screenshots = getattr(settings, 'MAX_CONCURRENT_SCREENSHOTS', 16)
        self.process_monitor = ProcessMonitor()
        self.no_action_timers = {}
        self.frame_processed_tasks: Dict[str, Set[str]] = defaultdict(set)
        self.device_sleep_until: Dict[str, float] = {}
        self.keep_checking_until: Dict[str, float] = {}
        self.keep_checking_task: Dict[str, str] = {}
        
        # Print initial device states on startup
        device_state_manager.print_all_device_states()
        
    async def batch_screenshot_all_devices(self, device_list: List[str]) -> Dict[str, any]:
        """Capture screenshots from multiple devices in parallel"""
        semaphore = asyncio.Semaphore(self.max_concurrent_screenshots)
        
        async def capture_device_screenshot(device_id):
            async with semaphore:
                try:
                    with suppress_stdout_stderr():
                        return await screenshot_manager.get_screenshot(device_id)
                except Exception:
                    return None
        
        screenshot_tasks = [
            asyncio.create_task(capture_device_screenshot(device_id)) 
            for device_id in device_list
        ]
        
        screenshots = await asyncio.gather(*screenshot_tasks, return_exceptions=True)
        
        return {
            device_id: screenshot 
            for device_id, screenshot in zip(device_list, screenshots)
            if screenshot is not None and not isinstance(screenshot, Exception)
        }
    
    async def execute_tap_with_offset(self, device_id: str, location_str: str, task: dict):
        """Execute tap with optional pixel offset adjustments"""
        if location_str == "0,0":
            return
            
        coords = location_str.split(',')
        x, y = int(coords[0]), int(coords[1])
        
        if 'UpPixels' in task:
            y -= task['UpPixels']
        if 'DownPixels' in task:
            y += task['DownPixels']
        if 'LeftPixels' in task:
            x -= task['LeftPixels']
        if 'RightPixels' in task:
            x += task['RightPixels']
        
        adjusted_location = f"{x},{y}"
        await execute_tap(device_id, adjusted_location)

    def get_prioritized_tasks(self, device_id: str) -> List[dict]:
        """Return tasks already sorted by priority from get_active_tasks, with KeepChecking filtering"""
        all_tasks = self.process_monitor.get_active_tasks(device_id)
        
        # Check if device is in KeepChecking mode
        current_time = time.time()
        if device_id in self.keep_checking_until:
            if current_time < self.keep_checking_until[device_id]:
                # Still in KeepChecking period - only return the specific task
                keep_checking_task_name = self.keep_checking_task.get(device_id)
                if keep_checking_task_name:
                    filtered_tasks = [task for task in all_tasks if task.get("task_name") == keep_checking_task_name]
                    if filtered_tasks:
                        return filtered_tasks
            else:
                # KeepChecking period expired - clear it
                del self.keep_checking_until[device_id]
                if device_id in self.keep_checking_task:
                    del self.keep_checking_task[device_id]
                print(f"[{device_id}] KeepChecking period expired, resuming normal task processing")
        
        return all_tasks

    def get_adaptive_interval(self, device_id: str) -> float:
        """Get adaptive check interval based on device stability"""
        if not getattr(settings, 'ADAPTIVE_CHECK_INTERVAL', True):
            return self.check_interval
            
        device_state = self.device_states.get(device_id, {'stable_count': 0, 'last_action': 0})
        
        if device_state['stable_count'] > 10:
            return self.check_interval * 2
        elif device_state['stable_count'] > 5:
            return self.check_interval * 1.5
        else:
            return self.check_interval
    
    async def handle_task_flags(self, device_id: str, task: dict):
        """Handle all task switching flags and update device state"""
        
        # Handle JSON flag updates first
        json_flags = [
            "json_EasyMode", "json_HardMode", "json_SideMode",
            "json_S_TheHumanWorld", "json_S_TheSoulSociety", 
            "json_S_HuecoMundo", "json_S_TheFutureSociety", "json_S_Others"
        ]
        
        for flag in json_flags:
            if task.get(flag, False):
                device_state_manager.set_json_flag(device_id, flag, 1)
        
        # Legacy handling for backward compatibility
        if "Part 21 Finished Detected" in task.get("task_name", ""):
            device_state_manager.mark_easy_mode_complete(device_id)
            print(f"[{device_id}] ✓ EasyMode complete")
        
        if task.get("SideStory", False) and "Part 21 Hard Chapter END" in task.get("task_name", ""):
            device_state_manager.mark_hard_mode_complete(device_id)
            print(f"[{device_id}] ✓ HardMode complete")
        
        if "Part 24 Chapter END" in task.get("task_name", ""):
            device_state_manager.mark_side_mode_active(device_id)
            print(f"[{device_id}] ✓ SideMode complete")
        
        # Handle standard task switching flags
        flag_handlers = {
            "BackToStory": ("main", "→ Main"),
            "NeedGuildTutorial": ("guild_tutorial", "→ Guild Tutorial"),
            "NeedToRejoin": ("guild_rejoin", "→ Guild Rejoin"),
            "isRefreshed": ("guild_tutorial", "→ Guild Tutorial"),
            "BackToRestartingTasks": ("restarting", "→ Restarting"),
            "BackToMain": ("main", "→ Main"),
            "Characters_Full": ("sell_characters", "→ Sell Characters"),
            "HardStory": ("hardstory", "→ Hard Story"),
            "SideStory": ("sidestory", "→ Side Story"),
            "Sub-Stores": ("substories", "→ Sub Stories"),
            "CheckSubStoriesAllCleared": ("substories_check", "→ Sub Stories Check")
        }
        
        # Special handling for transitioning from Restarting to Story
        if task.get("BackToStory", False):
            current_task_set = self.process_monitor.active_task_set.get(device_id, "restarting")
            if current_task_set == "restarting":
                recommended_mode = device_state_manager.should_skip_to_mode(device_id)
                if recommended_mode != "main":
                    print(f"[{device_id}] State override → {recommended_mode}")
                    self.process_monitor.set_active_tasks(device_id, recommended_mode)
                    return
        
        for flag, (task_set, message) in flag_handlers.items():
            if task.get(flag, False):
                shows_in = task.get("ShowsIn")
                if shows_in:
                    current_task_set = self.process_monitor.active_task_set.get(device_id, "restarting")
                    task_set_mapping = {
                        "main": "main_tasks",
                        "restarting": "restarting_tasks", 
                        "guild_tutorial": "guild_tutorial_tasks",
                        "guild_rejoin": "guild_rejoin_tasks",
                        "sell_characters": "sell_characters_tasks",
                        "hardstory": "hardstory_tasks",
                        "sidestory": "sidestory_tasks",
                        "substories": "substories_tasks",
                        "substories_check": "substories_check_tasks"
                    }
                    current_task_name = task_set_mapping.get(current_task_set, current_task_set)
                    
                    if current_task_name not in shows_in:
                        continue
                
                print(f"[{device_id}] {message}")
                self.process_monitor.set_active_tasks(device_id, task_set)
                break

    async def process_matched_tasks(self, device_id: str, matched_tasks: List[dict]) -> bool:
        """Process all matched tasks intelligently"""
        logical_triggered = False
        tasks_by_priority = defaultdict(list)
        
        for task in matched_tasks:
            priority = task.get('priority', 999)
            tasks_by_priority[priority].append(task)
        
        for priority in sorted(tasks_by_priority.keys()):
            priority_tasks = tasks_by_priority[priority]
            
            shared_tasks = [t for t in priority_tasks if t.get('shared_detection', False)]
            regular_tasks = [t for t in priority_tasks if not t.get('shared_detection', False)]
            
            for task in shared_tasks:
                task_name = task['task_name']
                
                if task_name in self.frame_processed_tasks[device_id]:
                    continue
                
                print(f"[{device_id}] {task_name}")
                
                self.no_action_timers[device_id] = time.time()
                self.frame_processed_tasks[device_id].add(task_name)
                
                should_restart = self.process_monitor.track_action(device_id, task_name)
                if should_restart:
                    await self.process_monitor.kill_and_restart_game(device_id)
                    return logical_triggered
                
                await self.handle_task_flags(device_id, task)
                
                if "[Multi:" not in task_name and "[Executed" not in task_name:
                    await self.execute_tap_with_offset(device_id, task["click_location_str"], task)
                
                # Handle KeepChecking flag
                if "KeepChecking" in task:
                    keep_checking_duration = float(task["KeepChecking"])
                    self.keep_checking_until[device_id] = time.time() + keep_checking_duration
                    self.keep_checking_task[device_id] = task_name
                    print(f"[{device_id}] KeepChecking '{task_name}' for {keep_checking_duration}s")
                
                if "sleep" in task:
                    sleep_duration = float(task["sleep"])
                    self.device_sleep_until[device_id] = time.time() + sleep_duration
                    print(f"[{device_id}] Sleeping {sleep_duration}s")
                
                if task.get("isLogical", False):
                    logical_triggered = True
                    if not hasattr(self, 'logical_task_info'):
                        self.logical_task_info = {}
                    self.logical_task_info[device_id] = task
                    return logical_triggered
                
                await asyncio.sleep(0.05)
            
            if regular_tasks and not logical_triggered:
                task = regular_tasks[0]
                task_name = task['task_name']
                
                if task_name not in self.frame_processed_tasks[device_id]:
                    print(f"[{device_id}] {task_name}")
                    
                    self.no_action_timers[device_id] = time.time()
                    self.frame_processed_tasks[device_id].add(task_name)
                    
                    should_restart = self.process_monitor.track_action(device_id, task_name)
                    if should_restart:
                        await self.process_monitor.kill_and_restart_game(device_id)
                        return logical_triggered
                    
                    await self.handle_task_flags(device_id, task)
                    
                    if "[Executed" not in task_name:
                        await self.execute_tap_with_offset(device_id, task["click_location_str"], task)
                    
                    # Handle KeepChecking flag
                    if "KeepChecking" in task:
                        keep_checking_duration = float(task["KeepChecking"])
                        self.keep_checking_until[device_id] = time.time() + keep_checking_duration
                        self.keep_checking_task[device_id] = task_name
                        print(f"[{device_id}] KeepChecking '{task_name}' for {keep_checking_duration}s")
                    
                    if "sleep" in task:
                        sleep_duration = float(task["sleep"])
                        self.device_sleep_until[device_id] = time.time() + sleep_duration
                        print(f"[{device_id}] Sleeping {sleep_duration}s")
                    
                    if task.get("isLogical", False):
                        logical_triggered = True
                        if not hasattr(self, 'logical_task_info'):
                            self.logical_task_info = {}
                        self.logical_task_info[device_id] = task
                    
                    break
        
        return logical_triggered

    def is_device_sleeping(self, device_id: str) -> bool:
        """Check if device is currently in sleep mode"""
        if device_id not in self.device_sleep_until:
            return False
        
        current_time = time.time()
        if current_time < self.device_sleep_until[device_id]:
            return True
        else:
            del self.device_sleep_until[device_id]
            return False
    
    async def watch_device_optimized(self, device_id: str) -> Optional[str]:
        """Optimized device watching with smart multi-detection and state tracking"""
        print(f"[{device_id}] Starting monitoring...")
        print(f"[{device_id}] {device_state_manager.get_progress_summary(device_id)}")
        
        self.device_states[device_id] = {'stable_count': 0, 'last_action': time.time()}
        self.no_action_timers[device_id] = time.time()
        
        while not self.stop_event.is_set():
            try:
                if self.is_device_sleeping(device_id):
                    await asyncio.sleep(0.1)
                    continue
                
                self.frame_processed_tasks[device_id].clear()
                
                if time.time() - self.no_action_timers.get(device_id, time.time()) > 240:
                    print(f"[{device_id}] 240s timeout - restarting")
                    await self.process_monitor.kill_and_restart_game(device_id)
                    self.no_action_timers[device_id] = time.time()
                
                if await self.process_monitor.should_check_process(device_id):
                    is_bleach_running = await self.process_monitor.is_bleach_running(device_id)
                    
                    if self.process_monitor.is_initial_setup_needed(device_id):
                        if not is_bleach_running:
                            print(f"[{device_id}] Game not running, launching...")
                            await self.process_monitor.launch_bleach(device_id)
                            self.process_monitor.set_active_tasks(device_id, "restarting")
                            device_state_manager.increment_counter(device_id, "RestartingCount")
                        else:
                            recommended_mode = device_state_manager.should_skip_to_mode(device_id)
                            self.process_monitor.set_active_tasks(device_id, recommended_mode)
                        
                        self.process_monitor.mark_initial_complete(device_id)
                    
                    elif not is_bleach_running:
                        print(f"[{device_id}] Game crashed, re-launching...")
                        await self.process_monitor.launch_bleach(device_id)
                        self.process_monitor.set_active_tasks(device_id, "restarting")
                        device_state_manager.increment_counter(device_id, "RestartingCount")
                
                all_tasks = self.get_prioritized_tasks(device_id)
                
                with suppress_stdout_stderr():
                    matched_tasks = await batch_check_pixels_enhanced(device_id, all_tasks)
                
                if matched_tasks:
                    logical_triggered = await self.process_matched_tasks(device_id, matched_tasks)
                    if logical_triggered:
                        return device_id
                    
                    self.device_states[device_id]['stable_count'] = 0
                else:
                    self.device_states[device_id]['stable_count'] += 1
                
                interval = self.get_adaptive_interval(device_id)
                await asyncio.sleep(interval)
                
            except Exception as e:
                print(f"[{device_id}] Monitoring error")
                await asyncio.sleep(1)
        
        return None
    
    async def monitor_all_devices(self) -> Optional[str]:
        """Monitor all devices concurrently"""
        self.stop_event.clear()
        
        if self.parallel_screenshots:
            return await self.monitor_all_devices_ultra_fast()
        
        tasks = [
            asyncio.create_task(self.watch_device_optimized(device_id))
            for device_id in settings.DEVICE_IDS
        ]
        
        done, pending = await asyncio.wait(
            tasks, 
            return_when=asyncio.FIRST_COMPLETED
        )
        
        self.stop_event.set()
        
        triggered_device = None
        for task in done:
            result = await task
            if result:
                triggered_device = result
                break
        
        for task in pending:
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                pass
        
        return triggered_device
    
    async def monitor_all_devices_ultra_fast(self) -> Optional[str]:
        """Ultra-fast monitoring with shared detection support and state tracking"""
        self.stop_event.clear()
        
        for device_id in settings.DEVICE_IDS:
            self.no_action_timers[device_id] = time.time()
        
        while not self.stop_event.is_set():
            try:
                for device_id in settings.DEVICE_IDS:
                    self.frame_processed_tasks[device_id].clear()
                
                for device_id in settings.DEVICE_IDS:
                    if time.time() - self.no_action_timers.get(device_id, time.time()) > 240:
                        print(f"[{device_id}] 240s timeout - restarting")
                        await self.process_monitor.kill_and_restart_game(device_id)
                        self.no_action_timers[device_id] = time.time()
                
                async def check_and_manage_device(device_id: str):
                    try:
                        if await self.process_monitor.should_check_process(device_id):
                            is_bleach_running = await self.process_monitor.is_bleach_running(device_id)
                            
                            if self.process_monitor.is_initial_setup_needed(device_id):
                                if not is_bleach_running:
                                    await self.process_monitor.launch_bleach(device_id)
                                    self.process_monitor.set_active_tasks(device_id, "restarting")
                                    device_state_manager.increment_counter(device_id, "RestartingCount")
                                else:
                                    recommended_mode = device_state_manager.should_skip_to_mode(device_id)
                                    self.process_monitor.set_active_tasks(device_id, recommended_mode)
                                
                                self.process_monitor.mark_initial_complete(device_id)
                            
                            elif not is_bleach_running:
                                await self.process_monitor.launch_bleach(device_id)
                                self.process_monitor.set_active_tasks(device_id, "restarting")
                                device_state_manager.increment_counter(device_id, "RestartingCount")
                    except Exception:
                        pass
                
                process_check_tasks = [
                    asyncio.create_task(check_and_manage_device(device_id))
                    for device_id in settings.DEVICE_IDS
                ]
                
                await asyncio.gather(*process_check_tasks, return_exceptions=True)
                
                active_devices = [
                    device_id for device_id in settings.DEVICE_IDS 
                    if not self.is_device_sleeping(device_id)
                ]
                
                with suppress_stdout_stderr():
                    device_screenshots = await self.batch_screenshot_all_devices(active_devices)
                
                for device_id, screenshot in device_screenshots.items():
                    if screenshot is not None:
                        all_tasks = self.get_prioritized_tasks(device_id)
                        
                        with suppress_stdout_stderr():
                            matched_tasks = await batch_check_pixels_enhanced(device_id, all_tasks, screenshot)
                        
                        if matched_tasks:
                            logical_triggered = await self.process_matched_tasks(device_id, matched_tasks)
                            if logical_triggered:
                                self.stop_event.set()
                                return device_id
                
                await asyncio.sleep(self.check_interval)
                
            except Exception:
                await asyncio.sleep(0.5)
        
        return None


# Global monitor instance
monitor = OptimizedBackgroundMonitor()

# Backward compatible functions
async def continuous_pixel_watch() -> Optional[str]:
    """Backward compatible wrapper for the optimized monitor"""
    return await monitor.monitor_all_devices()

async def watch_device_for_trigger(device_id: str) -> Optional[str]:
    """Backward compatible single device watcher"""
    return await monitor.watch_device_optimized(device_id)
```

## device_state_manager.py

```python
# device_state_manager.py - Enhanced with SubStory tracking and JSON flag support
import json
import os
from typing import Dict, Any
from datetime import datetime
import asyncio
from threading import Lock

class DeviceStateManager:
    """Manages persistent state for each device including character upgrades and substory progress"""
    
    def __init__(self):
        self.states: Dict[str, Dict[str, Any]] = {}
        self.state_dir = "device_states"
        self.locks: Dict[str, Lock] = {}
        self.device_mapping = {
            "127.0.0.1:16800": "DEVICE1",
            "127.0.0.1:16832": "DEVICE2",
            "127.0.0.1:16864": "DEVICE3",
            "127.0.0.1:16896": "DEVICE4",
            "127.0.0.1:16928": "DEVICE5",
            "127.0.0.1:16960": "DEVICE6",
            "127.0.0.1:16992": "DEVICE7",
            "127.0.0.1:17024": "DEVICE8",
            "127.0.0.1:17056": "DEVICE9",
            "127.0.0.1:17088": "DEVICE10"
        }
        
        # Create state directory if it doesn't exist
        os.makedirs(self.state_dir, exist_ok=True)
        
        # Initialize states for all devices
        self._initialize_all_devices()
    
    def _get_device_name(self, device_id: str) -> str:
        """Get device name from device ID"""
        return self.device_mapping.get(device_id, f"DEVICE_{device_id.replace(':', '_')}")
    
    def _get_state_file_path(self, device_name: str) -> str:
        """Get the JSON file path for a device"""
        return os.path.join(self.state_dir, f"{device_name}.json")
    
    def _get_default_state(self) -> Dict[str, Any]:
        """Get default state structure for a new device"""
        return {
            "EasyMode": 0,
            "HardMode": 0,
            "SideMode": 0,
            "SubStory": 0,  # Main SubStory flag
            "SubStory-TheHumanWorld": 0,
            "SubStory-TheSoulSociety": 0,
            "SubStory-HuecoMundo": 0,
            "SubStory-TheFutureSociety": 0,
            "SubStory-Others": 0,
            "RestartingCount": 0,
            "2-Stars-Upgraded": 0,
            "3-Stars-Upgraded": 0,
            "4-Stars-Upgraded": 0,
            "5-Stars-Upgraded": 0,
            "isLinked": False,
            "LastUpdated": datetime.now().isoformat(),
            "CurrentTaskSet": "restarting",
            "SessionStats": {
                "SessionStartTime": datetime.now().isoformat(),
                "TasksExecuted": 0,
                "LastTaskExecuted": None
            }
        }
    
    def _initialize_all_devices(self):
        """Initialize state files for all configured devices"""
        for device_id in self.device_mapping.keys():
            device_name = self._get_device_name(device_id)
            self.locks[device_id] = Lock()
            
            # Load or create state file
            state_file = self._get_state_file_path(device_name)
            
            if os.path.exists(state_file):
                try:
                    with open(state_file, 'r') as f:
                        loaded_state = json.load(f)
                        
                    # Ensure all required keys exist (for backward compatibility)
                    default_state = self._get_default_state()
                    for key, value in default_state.items():
                        if key not in loaded_state:
                            loaded_state[key] = value
                    
                    self.states[device_id] = loaded_state
                    print(f"[STATE] Loaded existing state for {device_name}")
                except Exception as e:
                    print(f"[STATE] Error loading state for {device_name}: {e}")
                    self.states[device_id] = self._get_default_state()
                    self._save_state(device_id)
            else:
                self.states[device_id] = self._get_default_state()
                self._save_state(device_id)
                print(f"[STATE] Created new state file for {device_name}")
    
    def _save_state(self, device_id: str):
        """Save device state to JSON file"""
        device_name = self._get_device_name(device_id)
        state_file = self._get_state_file_path(device_name)
        
        try:
            self.states[device_id]["LastUpdated"] = datetime.now().isoformat()
            with open(state_file, 'w') as f:
                json.dump(self.states[device_id], f, indent=2)
        except Exception as e:
            print(f"[STATE] Error saving state for {device_name}: {e}")
    
    def get_state(self, device_id: str) -> Dict[str, Any]:
        """Get current state for a device"""
        if device_id not in self.states:
            self.states[device_id] = self._get_default_state()
        return self.states[device_id].copy()
    
    def update_state(self, device_id: str, key: str, value: Any):
        """Update a specific state value for a device"""
        with self.locks.get(device_id, Lock()):
            if device_id not in self.states:
                self.states[device_id] = self._get_default_state()
            
            self.states[device_id][key] = value
            
            # Check if all SubStory sub-keys are complete
            self._check_substory_completion(device_id)
            
            self._save_state(device_id)
    
    def _check_substory_completion(self, device_id: str):
        """Check if all SubStory sub-keys are complete and update main SubStory flag"""
        substory_keys = [
            "SubStory-TheHumanWorld",
            "SubStory-TheSoulSociety",
            "SubStory-HuecoMundo",
            "SubStory-TheFutureSociety",
            "SubStory-Others"
        ]
        
        # Check if all substory keys are set to 1 (true)
        all_complete = all(
            self.states[device_id].get(key, 0) == 1 
            for key in substory_keys
        )
        
        if all_complete:
            self.states[device_id]["SubStory"] = 1
            print(f"[{self._get_device_name(device_id)}] ✓ All SubStories complete!")
    
    def set_json_flag(self, device_id: str, flag_name: str, value: Any = 1):
        """Set a JSON flag based on task detection"""
        # Map json_ prefixed flags to actual state keys
        flag_mapping = {
            "json_EasyMode": "EasyMode",
            "json_HardMode": "HardMode",
            "json_SideMode": "SideMode",
            "json_SubStory": "SubStory",
            "json_S_TheHumanWorld": "SubStory-TheHumanWorld",
            "json_S_TheSoulSociety": "SubStory-TheSoulSociety",
            "json_S_HuecoMundo": "SubStory-HuecoMundo",
            "json_S_TheFutureSociety": "SubStory-TheFutureSociety",
            "json_S_Others": "SubStory-Others"
        }
        
        if flag_name in flag_mapping:
            state_key = flag_mapping[flag_name]
            self.update_state(device_id, state_key, value)
            device_name = self._get_device_name(device_id)
            print(f"[{device_name}] Set {state_key} = {value}")
    
    def check_stop_support(self, device_id: str, stop_flag: str) -> bool:
        """Check if a task should be stopped based on device state"""
        # Map json_ prefixed flags to actual state keys
        flag_mapping = {
            "json_EasyMode": "EasyMode",
            "json_HardMode": "HardMode",
            "json_SideMode": "SideMode",
            "json_SubStory": "SubStory",
            "json_S_TheHumanWorld": "SubStory-TheHumanWorld",
            "json_S_TheSoulSociety": "SubStory-TheSoulSociety",
            "json_S_HuecoMundo": "SubStory-HuecoMundo",
            "json_S_TheFutureSociety": "SubStory-TheFutureSociety",
            "json_S_Others": "SubStory-Others"
        }
        
        if stop_flag in flag_mapping:
            state_key = flag_mapping[stop_flag]
            state = self.get_state(device_id)
            return state.get(state_key, 0) == 1
        
        return False
    
    def increment_counter(self, device_id: str, counter_name: str):
        """Increment a counter value"""
        with self.locks.get(device_id, Lock()):
            if device_id not in self.states:
                self.states[device_id] = self._get_default_state()
            
            current_value = self.states[device_id].get(counter_name, 0)
            self.states[device_id][counter_name] = current_value + 1
            self._save_state(device_id)
    
    def increment_star_upgrade(self, device_id: str, star_level: int):
        """Increment character upgrade counter for specific star level"""
        counter_name = f"{star_level}-Stars-Upgraded"
        if counter_name in ["2-Stars-Upgraded", "3-Stars-Upgraded", "4-Stars-Upgraded", "5-Stars-Upgraded"]:
            self.increment_counter(device_id, counter_name)
            device_name = self._get_device_name(device_id)
            print(f"[{device_name}] {counter_name}: {self.states[device_id][counter_name]}")
    
    def set_linked_status(self, device_id: str, is_linked: bool):
        """Set the linked status of a device account"""
        self.update_state(device_id, "isLinked", is_linked)
        device_name = self._get_device_name(device_id)
        status = "linked" if is_linked else "not linked"
        print(f"[{device_name}] Account {status}")
    
    def mark_easy_mode_complete(self, device_id: str):
        """Mark EasyMode as complete for a device"""
        self.update_state(device_id, "EasyMode", 1)
    
    def mark_hard_mode_complete(self, device_id: str):
        """Mark HardMode as complete (and EasyMode if not already)"""
        with self.locks.get(device_id, Lock()):
            if device_id not in self.states:
                self.states[device_id] = self._get_default_state()
            
            # If HardMode is complete, EasyMode must also be complete
            self.states[device_id]["EasyMode"] = 1
            self.states[device_id]["HardMode"] = 1
            self._save_state(device_id)
    
    def mark_side_mode_active(self, device_id: str):
        """Mark that SideMode is active (EasyMode and HardMode must be complete)"""
        with self.locks.get(device_id, Lock()):
            if device_id not in self.states:
                self.states[device_id] = self._get_default_state()
            
            # If SideMode is active, both Easy and Hard must be complete
            self.states[device_id]["EasyMode"] = 1
            self.states[device_id]["HardMode"] = 1
            self.states[device_id]["SideMode"] = 1
            self._save_state(device_id)
    
    def get_recommended_task_set(self, device_id: str) -> str:
        """Get the recommended task set based on device state"""
        state = self.get_state(device_id)
        
        if state.get("SubStory", 0) == 1:
            return "substory"
        
        if state.get("SideMode", 0) == 1:
            return "sidestory"
        
        if state.get("HardMode", 0) == 1:
            return "sidestory"
        
        if state.get("EasyMode", 0) == 1:
            return "hardstory"
        
        return "main"
    
    def should_skip_to_mode(self, device_id: str) -> str:
        """Determine if device should skip to a specific mode after restarting"""
        state = self.get_state(device_id)
        
        if state.get("SubStory", 0) == 1:
            return "substory"
        elif state.get("SideMode", 0) == 1:
            return "sidestory"
        elif state.get("HardMode", 0) == 1:
            return "sidestory"
        elif state.get("EasyMode", 0) == 1:
            return "hardstory"
        
        return "main"
    
    def update_session_stats(self, device_id: str, task_name: str):
        """Update session statistics"""
        with self.locks.get(device_id, Lock()):
            if device_id not in self.states:
                self.states[device_id] = self._get_default_state()
            
            if "SessionStats" not in self.states[device_id]:
                self.states[device_id]["SessionStats"] = {
                    "SessionStartTime": datetime.now().isoformat(),
                    "TasksExecuted": 0,
                    "LastTaskExecuted": None
                }
            
            self.states[device_id]["SessionStats"]["TasksExecuted"] += 1
            self.states[device_id]["SessionStats"]["LastTaskExecuted"] = task_name
            self._save_state(device_id)
    
    def get_progress_summary(self, device_id: str) -> str:
        """Get a summary of device progress"""
        state = self.get_state(device_id)
        device_name = self._get_device_name(device_id)
        
        modes = []
        if state.get("EasyMode", 0) == 1:
            modes.append("Easy✓")
        if state.get("HardMode", 0) == 1:
            modes.append("Hard✓")
        if state.get("SideMode", 0) == 1:
            modes.append("Side✓")
        if state.get("SubStory", 0) == 1:
            modes.append("Sub✓")
        
        # Check individual substories
        substories = []
        if state.get("SubStory-TheHumanWorld", 0) == 1:
            substories.append("HW")
        if state.get("SubStory-TheSoulSociety", 0) == 1:
            substories.append("SS")
        if state.get("SubStory-HuecoMundo", 0) == 1:
            substories.append("HM")
        if state.get("SubStory-TheFutureSociety", 0) == 1:
            substories.append("FS")
        if state.get("SubStory-Others", 0) == 1:
            substories.append("O")
        
        if not modes:
            modes.append("Starting")
        
        restart_count = state.get("RestartingCount", 0)
        linked = "Linked" if state.get("isLinked", False) else "Unlinked"
        
        # Character upgrades summary
        upgrades = []
        for stars in [2, 3, 4, 5]:
            count = state.get(f"{stars}-Stars-Upgraded", 0)
            if count > 0:
                upgrades.append(f"{stars}★:{count}")
        
        upgrade_str = f" Upgrades[{', '.join(upgrades)}]" if upgrades else ""
        substory_str = f" Sub[{','.join(substories)}]" if substories else ""
        
        return f"{device_name}: [{' → '.join(modes)}] ({linked}) Restarts:{restart_count}{substory_str}{upgrade_str}"
    
    def print_all_device_states(self):
        """Print a summary of all device states"""
        print("\n" + "="*70)
        print("DEVICE STATE SUMMARY")
        print("="*70)
        
        for device_id in sorted(self.device_mapping.keys()):
            print(self.get_progress_summary(device_id))
        
        print("="*70 + "\n")

# Global instance
device_state_manager = DeviceStateManager()
```

## logical_process.py

```python
# logical_process.py
import asyncio
# Import the functions from actions
from actions import screenshot_manager, find_template_in_region, execute_tap, execute_swipe

async def run_hard_mode_swipes(device_id):
    """
    Execute smart swipe sequence to find Part-1 HARD template.
    Check for template before and after each swipe, stop when found.
    Maximum 7 swipes if template never appears.
    """
    print(f"\n--- Executing Smart Hard Mode Swipe Sequence on {device_id} ---")
    
    # First check if Part-1 HARD template is already visible
    print(f"[{device_id}] Checking if Part-1 HARD template is already visible...")
    screenshot = await screenshot_manager.get_screenshot(device_id)
    
    if screenshot is not None:
        part1_hard_pos = await find_template_in_region(
            screenshot,
            "templates/Part1_hard.png",
            [135, 113, 491, 290],  # ROI from task definition
            0.90  # Confidence from task definition
        )
        
        if part1_hard_pos:
            print(f"[{device_id}] Part-1 HARD template already found at {part1_hard_pos} - no swipes needed!")
            return
    
    # Execute swipes until template is found or max swipes reached
    for i in range(7):
        swipe_num = i + 1
        print(f"[{device_id}] Executing swipe {swipe_num}/7...")
        
        # Execute the swipe: from (0, 270) to (959, 270) with 700ms duration
        await execute_swipe(device_id, 0, 270, 959, 270, 700)
        
        # Wait 2 seconds for content to load
        print(f"[{device_id}] Waiting 2 seconds for content to load...")
        await asyncio.sleep(2)
        
        # Check if Part-1 HARD template is now visible
        print(f"[{device_id}] Checking for Part-1 HARD template after swipe {swipe_num}...")
        screenshot = await screenshot_manager.get_screenshot(device_id)
        
        if screenshot is not None:
            part1_hard_pos = await find_template_in_region(
                screenshot,
                "templates/Part1_hard.png",
                [135, 113, 491, 290],  # ROI from task definition
                0.85  # Confidence from task definition
            )
            
            if part1_hard_pos:
                print(f"[{device_id}] ✅ Part-1 HARD template found at {part1_hard_pos} after {swipe_num} swipe(s)!")
                print(f"[{device_id}] Smart swipe sequence complete - target found efficiently!")
                return
        else:
            print(f"[{device_id}] Failed to capture screenshot after swipe {swipe_num}")
    
    print(f"[{device_id}] ⚠️ Part-1 HARD template not found after 7 swipes - sequence complete")
```

## main.py

```python
# main.py - Enhanced with clean logging and state tracking
import asyncio
import atexit
import signal
from suppress_warnings import suppress_libpng_warning
suppress_libpng_warning()

from background_process import monitor
from screenrecord_manager import cleanup_all_screenrecord
from logical_process import run_hard_mode_swipes
from device_state_manager import device_state_manager

def cleanup_handler(signum=None, frame=None):
    """Clean up screenrecord streaming resources on exit"""
    print("\n🧹 Cleaning up resources...")
    cleanup_all_screenrecord()
    
    # Force kill any remaining ADB/FFmpeg processes
    import subprocess
    try:
        subprocess.run("taskkill /f /im ffmpeg.exe", shell=True, capture_output=True)
    except:
        pass
    
    print("✅ Cleanup complete")

def main():
    """Main entry point for the background monitoring script."""
    # Register cleanup handlers
    atexit.register(cleanup_handler)
    signal.signal(signal.SIGINT, cleanup_handler)
    signal.signal(signal.SIGTERM, cleanup_handler)
    
    print("🚀 Starting background monitoring...")
    print("📊 Loading device states...")
    
    try:
        # Start continuous monitoring loop with logical task handling
        asyncio.run(run_monitoring_with_logical_tasks())
    except KeyboardInterrupt:
        print("\n🛑 Monitoring stopped by user.")
        cleanup_handler()
    except Exception as e:
        print(f"Error occurred: {e}")
        cleanup_handler()
    finally:
        cleanup_handler()

async def run_monitoring_with_logical_tasks():
    """Run parallel monitoring for all devices with per-device logical task handling"""
    import settings
    
    # Print initial state summary
    device_state_manager.print_all_device_states()
    
    # Create monitoring tasks for each device
    device_tasks = []
    for device_id in settings.DEVICE_IDS:
        task = asyncio.create_task(monitor_single_device_with_logical_tasks(device_id))
        device_tasks.append(task)
    
    try:
        # Run all device monitoring in parallel
        await asyncio.gather(*device_tasks)
    except Exception as e:
        print(f"Error in parallel monitoring: {e}")
        # Cancel all tasks on error
        for task in device_tasks:
            if not task.done():
                task.cancel()

async def monitor_single_device_with_logical_tasks(device_id: str):
    """Monitor a single device and handle its logical tasks independently"""
    while True:
        try:
            # Monitor this specific device for logical tasks
            triggered_device = await monitor.watch_device_optimized(device_id)
            
            if triggered_device:
                print(f"\n◉ [{triggered_device}] Trigger detected!")
                
                # Get logical task info from monitor
                logical_task_info = getattr(monitor, 'logical_task_info', {})
                task_info = logical_task_info.get(triggered_device, {})
                
                # Only check for and run the hard mode swipe logic
                if task_info.get("HardModeSwipe", False):
                    print(f"[{triggered_device}] Executing Hard Mode swipes...")
                    await run_hard_mode_swipes(triggered_device)
                
                print(f"✓ [{triggered_device}] Logical process complete")
                
                # Clear the logical task info after processing
                if hasattr(monitor, 'logical_task_info') and triggered_device in monitor.logical_task_info:
                    del monitor.logical_task_info[triggered_device]
                    
        except Exception as e:
            print(f"[{device_id}] Monitoring error")
            await asyncio.sleep(1)

if __name__ == '__main__':
    main()
```

## screenrecord_manager.py

```python
"""
High-Performance Screen Capture using ADB screenrecord streaming
No device binaries required - uses built-in Android screenrecord
"""
import asyncio
import subprocess
import threading
import time
import io
from typing import Optional, Dict
from dataclasses import dataclass
import numpy as np
import cv2

@dataclass
class StreamFrame:
    """Represents a decoded frame from screenrecord stream"""
    image: np.ndarray
    timestamp: float
    width: int
    height: int

class ScreenrecordManager:
    """High-performance streaming capture using adb screenrecord"""
    
    def __init__(self, device_id: str):
        self.device_id = device_id
        self.process = None
        self.running = False
        self.last_frame: Optional[StreamFrame] = None
        self.frame_lock = threading.Lock()
        self.reader_thread = None
        self.cap = None
        
        # Stream settings
        self.bitrate = "8M"  # High quality
        self.size = "720x1280"  # Reduce for performance, scale up if needed
        self.time_limit = "3600"  # 1 hour max
        
    async def initialize(self):
        """Initialize screenrecord streaming"""
        try:
            print(f"[{self.device_id}] Basic screenrecord streaming disabled (requires FFmpeg for H264 decoding)")
            return False  # Disable basic streaming since it requires complex H264 decoding
            
        except Exception as e:
            print(f"[{self.device_id}] Failed to initialize screenrecord: {e}")
            return False
    
    async def _start_screenrecord_stream(self):
        """Start adb screenrecord streaming process"""
        # Kill any existing screenrecord
        kill_cmd = f"adb -s {self.device_id} shell pkill -f screenrecord"
        subprocess.run(kill_cmd, shell=True, capture_output=True)
        
        # Start streaming screenrecord
        cmd = [
            "adb", "-s", self.device_id, "exec-out",
            "screenrecord", 
            "--output-format=h264",
            f"--bit-rate={self.bitrate}",
            f"--size={self.size}",
            f"--time-limit={self.time_limit}",
            "--verbose",
            "-"  # Output to stdout
        ]
        
        self.process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            bufsize=0  # Unbuffered for real-time streaming
        )
        
        print(f"[{self.device_id}] Started screenrecord stream: {' '.join(cmd)}")
    
    def _frame_reader(self):
        """Read and decode H264 stream frames"""
        if not self.process or not self.process.stdout:
            return
            
        # Create OpenCV VideoCapture from pipe
        # Note: This approach reads raw H264 stream
        buffer = b''
        frame_buffer = bytearray()
        
        while self.running and self.process and self.process.poll() is None:
            try:
                # Read chunk from stream
                chunk = self.process.stdout.read(8192)
                if not chunk:
                    time.sleep(0.001)
                    continue
                
                buffer += chunk
                
                # Try to decode frames from buffer
                # For H264, we need to find frame boundaries (NAL units)
                self._process_h264_buffer(buffer)
                
                # Keep only recent data to prevent memory buildup
                if len(buffer) > 1024 * 1024:  # 1MB max buffer
                    buffer = buffer[-512*1024:]  # Keep last 512KB
                    
            except Exception as e:
                if self.running:
                    print(f"[{self.device_id}] Frame reader error: {e}")
                    time.sleep(0.1)
    
    def _process_h264_buffer(self, buffer: bytes):
        """Process H264 buffer and extract frames"""
        try:
            # Create a temporary file-like object for OpenCV
            temp_buffer = io.BytesIO(buffer)
            
            # Try to create VideoCapture from buffer
            # This is a simplified approach - in production you'd want proper H264 parsing
            
            # For now, let's use a different approach: write to temp file and read
            # This is not the most efficient but works reliably
            temp_file = f"/tmp/stream_{self.device_id}.h264"
            
            # Write recent buffer to temp file
            with open(temp_file, 'wb') as f:
                f.write(buffer[-100000:])  # Last 100KB
            
            # Try to read with OpenCV
            cap = cv2.VideoCapture(temp_file)
            
            if cap.isOpened():
                ret, frame = cap.read()
                if ret and frame is not None:
                    # Convert BGR to RGB
                    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                    
                    with self.frame_lock:
                        self.last_frame = StreamFrame(
                            image=frame_rgb,
                            timestamp=time.time(),
                            width=frame_rgb.shape[1],
                            height=frame_rgb.shape[0]
                        )
                
                cap.release()
            
        except Exception as e:
            # Silently ignore decode errors - they're common with streaming
            pass
    
    async def get_screenshot(self) -> Optional[np.ndarray]:
        """Get the latest frame as NumPy array"""
        with self.frame_lock:
            if self.last_frame is not None:
                # Check if frame is recent (within 1 second)
                if time.time() - self.last_frame.timestamp < 1.0:
                    return self.last_frame.image
        
        # Fallback to regular screencap if no recent frame
        return await self._fallback_screencap()
    
    async def _fallback_screencap(self) -> Optional[np.ndarray]:
        """Fallback to regular ADB screencap"""
        try:
            command = f"adb -s {self.device_id} exec-out screencap -p"
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if stdout:
                from PIL import Image
                pil_image = Image.open(io.BytesIO(stdout)).convert('RGB')
                return np.asarray(pil_image)
                
        except Exception as e:
            print(f"[{self.device_id}] Fallback screencap failed: {e}")
            
        return None
    
    def cleanup(self):
        """Clean up streaming resources"""
        self.running = False
        
        if self.process:
            try:
                self.process.terminate()
                self.process.wait(timeout=5)
            except:
                try:
                    self.process.kill()
                except:
                    pass
        
        # Kill any remaining screenrecord processes on device
        try:
            kill_cmd = f"adb -s {self.device_id} shell pkill -f screenrecord"
            subprocess.run(kill_cmd, shell=True, capture_output=True, timeout=5)
        except:
            pass
        
        # Clean up temp files
        try:
            import os
            temp_file = f"/tmp/stream_{self.device_id}.h264"
            if os.path.exists(temp_file):
                os.remove(temp_file)
        except:
            pass
        
        print(f"[{self.device_id}] Screenrecord cleaned up")

# Alternative implementation using FFmpeg for better H264 handling
class FFmpegScreenrecordManager:
    """Enhanced version using FFmpeg for H264 decoding"""
    
    def __init__(self, device_id: str):
        self.device_id = device_id
        self.screenrecord_process = None
        self.ffmpeg_process = None
        self.running = False
        self.last_frame: Optional[StreamFrame] = None
        self.frame_lock = threading.Lock()
        self.reader_thread = None
        
    async def initialize(self):
        """Initialize with FFmpeg pipeline"""
        try:
            # Check if FFmpeg is available
            result = subprocess.run(["ffmpeg", "-version"], capture_output=True)
            if result.returncode != 0:
                print(f"[{self.device_id}] FFmpeg not found, using basic implementation")
                return False
            
            await self._start_ffmpeg_pipeline()
            
            self.running = True
            self.reader_thread = threading.Thread(target=self._ffmpeg_frame_reader, daemon=True)
            self.reader_thread.start()
            
            print(f"[{self.device_id}] FFmpeg screenrecord streaming initialized")
            return True
            
        except Exception as e:
            print(f"[{self.device_id}] FFmpeg initialization failed: {e}")
            return False
    
    async def _start_ffmpeg_pipeline(self):
        """Start screenrecord -> FFmpeg pipeline"""
        # Kill existing processes
        kill_cmd = f"adb -s {self.device_id} shell pkill -f screenrecord"
        subprocess.run(kill_cmd, shell=True, capture_output=True)
        
        # Start screenrecord
        screenrecord_cmd = [
            "adb", "-s", self.device_id, "exec-out",
            "screenrecord", "--output-format=h264", "--bit-rate=8M",
            "--size=720x1280", "--time-limit=3600", "-"
        ]
        
        self.screenrecord_process = subprocess.Popen(
            screenrecord_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Start FFmpeg to decode H264 -> raw frames
        ffmpeg_cmd = [
            "ffmpeg", "-f", "h264", "-i", "pipe:0",
            "-f", "rawvideo", "-pix_fmt", "rgb24", 
            "-an", "-sn", "pipe:1"
        ]
        
        self.ffmpeg_process = subprocess.Popen(
            ffmpeg_cmd,
            stdin=self.screenrecord_process.stdout,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Close screenrecord stdout in parent
        self.screenrecord_process.stdout.close()
    
    def _ffmpeg_frame_reader(self):
        """Read decoded frames from FFmpeg"""
        if not self.ffmpeg_process:
            return
        
        frame_size = 720 * 1280 * 3  # Width * Height * RGB
        
        while self.running and self.ffmpeg_process.poll() is None:
            try:
                # Read one frame worth of data
                frame_data = self.ffmpeg_process.stdout.read(frame_size)
                
                if len(frame_data) == frame_size:
                    # Convert raw RGB data to numpy array
                    frame = np.frombuffer(frame_data, dtype=np.uint8)
                    frame = frame.reshape((1280, 720, 3))
                    
                    with self.frame_lock:
                        self.last_frame = StreamFrame(
                            image=frame,
                            timestamp=time.time(),
                            width=720,
                            height=1280
                        )
                
            except Exception as e:
                if self.running:
                    print(f"[{self.device_id}] FFmpeg reader error: {e}")
                    time.sleep(0.1)
    
    async def get_screenshot(self) -> Optional[np.ndarray]:
        """Get latest frame"""
        with self.frame_lock:
            if self.last_frame and time.time() - self.last_frame.timestamp < 1.0:
                return self.last_frame.image
        return None
    
    def cleanup(self):
        """Cleanup FFmpeg processes"""
        self.running = False
        
        for process in [self.ffmpeg_process, self.screenrecord_process]:
            if process:
                try:
                    process.terminate()
                    process.wait(timeout=5)
                except:
                    try:
                        process.kill()
                    except:
                        pass

# Global managers
screenrecord_managers: Dict[str, ScreenrecordManager] = {}

async def get_screenrecord_manager(device_id: str) -> Optional[ScreenrecordManager]:
    """Get or create screenrecord manager for device"""
    if device_id not in screenrecord_managers:
        # Try FFmpeg version first, fallback to basic
        manager = FFmpegScreenrecordManager(device_id)
        if not await manager.initialize():
            manager = ScreenrecordManager(device_id)
            if not await manager.initialize():
                return None
        
        screenrecord_managers[device_id] = manager
    
    return screenrecord_managers.get(device_id)

def cleanup_all_screenrecord():
    """Clean up all screenrecord managers"""
    for manager in screenrecord_managers.values():
        manager.cleanup()
    screenrecord_managers.clear()

```

## settings.py

```python
# settings.py - Enhanced with performance options
import os
# Device configuration
DEVICE_IDS = [
  "127.0.0.1:16800",
  "127.0.0.1:16832",
  "127.0.0.1:16864",
  "127.0.0.1:16896",
  "127.0.0.1:16928",
  "127.0.0.1:16960",
  "127.0.0.1:16992",
  "127.0.0.1:17024",
  "127.0.0.1:17056",
  "127.0.0.1:17088"
]
# -------------------
# PERFORMANCE SETTINGS
# -------------------
# Screenshot caching duration (seconds) - reduces redundant captures
SCREENSHOT_CACHE_DURATION = 0.8  # Increased for better caching

# Batch processing size - how many tasks to check per screenshot
TASK_BATCH_SIZE = 8  # Increased batch size for efficiency

# Background check interval (seconds) - how often to cycle through tasks
BACKGROUND_CHECK_INTERVAL = 0.2  # Faster checking

# Parallel screenshot capture for all devices
PARALLEL_SCREENSHOT_CAPTURE = True

# Maximum concurrent screenshot operations
MAX_CONCURRENT_SCREENSHOTS = 16  # Half of device count for optimal performance

# Smart task prioritization - check high-priority tasks first
USE_TASK_PRIORITIZATION = True

# Skip checking stable devices as frequently
ADAPTIVE_CHECK_INTERVAL = True

# Use async processing instead of threads (recommended)
USE_ASYNC_PROCESSING = True

# Maximum concurrent ADB connections per device
MAX_ADB_CONNECTIONS = 2

# Enable GPU memory pooling for better performance
ENABLE_GPU_MEMORY_POOL = True

# Screenshot quality (1-100) - lower = faster but less accurate
SCREENSHOT_QUALITY = 85

# -------------------
# OPTIMIZATION FLAGS
# -------------------
# Skip bounds checking for known good coordinates (small performance gain)
SKIP_BOUNDS_CHECK = False

# Use persistent ADB connections (experimental)
USE_PERSISTENT_ADB = False

# Enable performance profiling
ENABLE_PROFILING = False

# -------------------
# GAME & APP SETTINGS
# -------------------
GAME_PACKAGE_NAME = 'com.bandainamcoent.dblegends_ww'
GAME_ACTIVITY_NAME = f'{GAME_PACKAGE_NAME}.UnityPlayerActivity'

# -------------------
# FILE & PATH SETTINGS
# -------------------
LOCAL_STOCKS_PATH_BASE = os.path.join(os.path.expanduser('~'), 'Desktop', 'STOCKS')
REMOTE_DATA_DIR = f'/storage/emulated/0/Android/data/{GAME_PACKAGE_NAME}/files'
ECD_FILES = {
    'PRIMARY': 'ecd1bb8b626d380e93748523485ef051',
    'SECONDARY': '2b7038f1a0d3b9c9e57f3954bfa7672a',
    'IMAGE': '89bb4eb5637df3cd96c463a795005065',
}

# -------------------
# AUTOMATION SETTINGS
# -------------------
EMULATOR_RESOLUTION = (960, 540)

# Number of concurrent threads (only used if USE_ASYNC_PROCESSING is False)
NUM_THREADS = 4

# Coordinates to check for a black screen after launch
BLACK_SCREEN_PIXELS = [
    (100, 200),
    (400, 200),
    (100, 800),
    (400, 800),
]

# How long to wait for a black screen before restarting the game (in seconds)
BLACK_SCREEN_TIMEOUT = 15

# -------------------
# GPU OPTIMIZATION
# -------------------
# GPU optimization disabled - using NumPy instead of CuPy
ENABLE_GPU_MEMORY_POOL = False
```

## suppress_warnings.py

```python
# suppress_warnings.py - Suppress libpng and other warnings
import warnings
import os
import sys
import ctypes
import io
from contextlib import contextmanager

# Global variable to track if stderr has been redirected
_stderr_redirected = False

def suppress_libpng_warning():
    """Suppress libpng warnings that clutter the console"""
    global _stderr_redirected
    
    # Set environment variables FIRST before any imports
    os.environ['OPENCV_IO_ENABLE_OPENEXR'] = '0'
    os.environ['OPENCV_LOG_LEVEL'] = 'SILENT'
    os.environ['OPENCV_IO_MAX_IMAGE_PIXELS'] = '1073741824'  # 1GB limit instead of 0
    os.environ['PYTHONWARNINGS'] = 'ignore'
    
    # Suppress Python warnings
    warnings.filterwarnings("ignore")
    
    # Aggressive C-level stderr redirection
    if not _stderr_redirected:
        try:
            if sys.platform == "win32":
                # Windows: Redirect stderr file descriptor to NUL
                import msvcrt
                # Open NUL device
                nul_fd = os.open('NUL', os.O_WRONLY)
                # Duplicate stderr (fd 2) to NUL
                os.dup2(nul_fd, 2)
                os.close(nul_fd)
                _stderr_redirected = True
            else:
                # Unix/Linux: Redirect stderr to /dev/null
                devnull_fd = os.open('/dev/null', os.O_WRONLY)
                os.dup2(devnull_fd, 2)
                os.close(devnull_fd)
                _stderr_redirected = True
        except (OSError, AttributeError):
            # Fallback: Try ctypes approach
            try:
                if sys.platform == "win32":
                    # Windows ctypes approach
                    kernel32 = ctypes.windll.kernel32
                    # Get stderr handle
                    stderr_handle = kernel32.GetStdHandle(-12)  # STD_ERROR_HANDLE
                    # Open NUL device
                    nul_handle = kernel32.CreateFileW(
                        "NUL", 0x40000000, 0, None, 3, 0, None
                    )
                    # Set stderr to NUL
                    kernel32.SetStdHandle(-12, nul_handle)
                    _stderr_redirected = True
                else:
                    # Unix ctypes approach
                    libc = ctypes.CDLL("libc.so.6")
                    # Redirect stderr (fd 2) to /dev/null
                    devnull = libc.open(b"/dev/null", 1)  # O_WRONLY
                    libc.dup2(devnull, 2)
                    libc.close(devnull)
                    _stderr_redirected = True
            except:
                pass
    
    # Suppress libpng warnings at OpenCV level
    try:
        import cv2
        cv2.setLogLevel(0)  # Completely silent
    except ImportError:
        pass
    
    # PIL/Pillow suppression
    try:
        from PIL import Image
        Image.MAX_IMAGE_PIXELS = None
    except ImportError:
        pass

@contextmanager
def suppress_stdout_stderr():
    """Context manager to suppress stdout and stderr temporarily"""
    old_stdout = sys.stdout
    old_stderr = sys.stderr
    try:
        sys.stdout = io.StringIO()
        sys.stderr = io.StringIO()
        yield
    finally:
        sys.stdout = old_stdout
        sys.stderr = old_stderr

# Initialize suppression when module is imported
suppress_libpng_warning()
```

## task_runner.py

```python
# task_runner.py
import asyncio
import os
from datetime import datetime
import settings

# Import from our actions file and other modules
from actions import run_adb_command
from logical_process import run_logical_tasks, run_hard_mode_swipes
# Import the monitor instance directly to run it per-device
from background_process import monitor

# --- Logging Functions ---
def log_stock_completion(stock_number: int):
    """Logs when a stock is completed to logs.txt file."""
    current_time = datetime.now().strftime("%H:%M")
    log_message = f"STOCK #{stock_number} FINISHED AT {current_time}\n"
    
    try:
        with open("logs.txt", "a", encoding="utf-8") as log_file:
            log_file.write(log_message)
        print(f"📝 Logged completion: {log_message.strip()}")
    except Exception as e:
        print(f"❌ Error writing to logs.txt: {e}")

# --- Stock and Game Management (Orchestration Level) ---
async def import_stock_for_device(device_id, device_index, stock_number):
    """Imports the correct stock file for a single device with added delays for stability."""
    print(f"Processing Device #{device_index} ({device_id}) with Stock #{stock_number}...")
    
    # 1. Delete old files
    print(f"  -> Deleting old files for device {device_index}...")
    for file_key in settings.ECD_FILES:
        remote_path = f"{settings.REMOTE_DATA_DIR}/{settings.ECD_FILES[file_key]}"
        await run_adb_command(f"shell rm -f {remote_path}", device_id)
    
    await asyncio.sleep(1.0)

    # 2. Push new ECD file
    stock_folder = os.path.join(settings.LOCAL_STOCKS_PATH_BASE, str(stock_number), str(device_index))
    local_ecd_path = os.path.join(stock_folder, settings.ECD_FILES['PRIMARY'])
    
    if not os.path.exists(local_ecd_path):
        print(f"  -> ❌ Error: ECD file not found for device {device_index} at {local_ecd_path}")
        return False
        
    print(f"  -> Pushing new stock file for device {device_index}...")
    remote_ecd_path = f"{settings.REMOTE_DATA_DIR}/{settings.ECD_FILES['PRIMARY']}"
    await run_adb_command(f"push \"{local_ecd_path}\" \"{remote_ecd_path}\"", device_id)
    
    await asyncio.sleep(1.0)
    
    print(f"  -> ✅ Successfully pushed stock for device {device_index}.")
    return True

# --- Game Lifecycle Functions ---
async def launch_game(device_id):
    """Launches the game on the specified device using the monkey command."""
    command = f"shell monkey -p {settings.GAME_PACKAGE_NAME} -c android.intent.category.LAUNCHER 1"
    await run_adb_command(command, device_id)

async def kill_game(device_id):
    """Kills the game process on the specified device."""
    await run_adb_command(f"shell am force-stop {settings.GAME_PACKAGE_NAME}", device_id)

# --- NEW: Independent Device Automation Cycle ---
async def run_full_cycle_for_device(device_id: str):
    """Launches, monitors, and processes logical tasks for a single, independent device."""
    print(f"🚀 [{device_id}] Starting full automation cycle.")
    
    # 1. Launch the game on this device
    await launch_game(device_id)
    await asyncio.sleep(2) # Give the game a moment to start

    # 2. Enter the monitoring phase for this specific device.
    # This function will now wait until this specific device finds its logical trigger.
    print(f"🧐 [{device_id}] Entering background monitoring...")
    triggered_device = await monitor.watch_device_optimized(device_id)

    # 3. If a logical trigger was found, run the sequence and clean up.
    if triggered_device:
        print(f"\n❗ [{device_id}] Trigger detected! Switching to logical process...")
        
        # Check if this is a hard mode swipe task
        logical_task_info = getattr(monitor, 'logical_task_info', {})
        task_info = logical_task_info.get(triggered_device, {})
        
        print(f"[{triggered_device}] DEBUG: Logical task info: {task_info}")
        
        if task_info.get("HardModeSwipe", False):
            print(f"[{triggered_device}] Hard Mode detected - executing swipe sequence...")
            await run_hard_mode_swipes(triggered_device)
        else:
            # Default logical task (clear story logic)
            print(f"[{triggered_device}] Running default logical tasks...")
            await run_logical_tasks(triggered_device)
        
        print(f"👍 [{device_id}] Logical process finished. Killing game.")
        await kill_game(triggered_device)
    else:
        # This can happen if monitoring is interrupted (e.g., by Ctrl+C)
        print(f"🛑 [{device_id}] Monitoring stopped without a trigger. Killing game.")
        await kill_game(device_id)

# --- REVISED: Main Orchestration Loop ---
async def process_stocks(stocks_to_process: list[int]):
    """Orchestrates the automation for a list of stocks, running devices in parallel."""
    
    for stock_number in stocks_to_process:
        print(f"\n--- ⚙️ Starting Cycle with Stock #{stock_number} ⚙️ ---")
        
        # STEP 1: Prepare all devices by importing the correct stock files.
        import_tasks = [
            import_stock_for_device(dev_id, i + 1, stock_number)
            for i, dev_id in enumerate(settings.DEVICE_IDS)
        ]
        results = await asyncio.gather(*import_tasks)

        if not all(results):
            print(f"⚠️ Error importing stock #{stock_number}. Skipping to the next stock.")
            continue
        
        print(f"\n✅ Stock #{stock_number} import complete for all devices.")
        print("🚀 Starting parallel automation cycles for all devices...")
        
        # STEP 2: Run the full, independent automation cycle for each device concurrently.
        # asyncio.gather will wait for ALL devices to finish their tasks before proceeding.
        device_tasks = [
            run_full_cycle_for_device(dev_id) 
            for dev_id in settings.DEVICE_IDS
        ]
        await asyncio.gather(*device_tasks)

        print(f"\n--- ✅ All devices finished processing Stock #{stock_number} ✅ ---")
        
        # Log the completion of this stock
        log_stock_completion(stock_number)
    
    print("\n🎉 --- All selected stocks have been processed. Automation finished. ---")
```


